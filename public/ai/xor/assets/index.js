var ye = Object.defineProperty; var Se = (e, t, i) => t in e ? ye(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i; var u = (e, t, i) => (Se(e, typeof t != "symbol" ? t + "" : t, i), i); const Me = function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const n of document.querySelectorAll('link[rel="modulepreload"]')) s(n); new MutationObserver(n => { for (const r of n) if (r.type === "childList") for (const a of r.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && s(a) }).observe(document, { childList: !0, subtree: !0 }); function i(n) { const r = {}; return n.integrity && (r.integrity = n.integrity), n.referrerpolicy && (r.referrerPolicy = n.referrerpolicy), n.crossorigin === "use-credentials" ? r.credentials = "include" : n.crossorigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r } function s(n) { if (n.ep) return; n.ep = !0; const r = i(n); fetch(n.href, r) } }; Me(); let Lt = 0, be = 300; const Ct = { callback: () => { }, animate: e => { Ct.callback = e } }, Dt = () => { requestAnimationFrame(Dt); let e = Date.now(), t = e - Lt, i = 1e3 / be; t > i && (Lt = e - t % i, Ct.callback()) }; var ke = {}, nt = {}; Object.defineProperty(nt, "__esModule", { value: !0 }); nt.Vector = void 0; class T { constructor(t = 0, i = 0, s = 0) { this.x = t, this.y = i, this.z = s } add(t, i = 0, s = 0) { return typeof t == "number" ? (this.x += t, this.y += i, this.z += s, this) : (this.x += t.x, this.y += t.y, this.z += t.z, this) } sub(t, i = 0, s = 0) { return typeof t == "number" ? (this.x -= t, this.y -= i, this.z -= s, this) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this) } mult(t) { return isFinite(t) ? (this.x *= t, this.y *= t, this.z *= t, this) : this } div(t) { return !isFinite(t) || t == 0 ? this : (this.x /= t, this.y /= t, this.z /= t, this) } set(t, i = 0, s = 0) { return typeof t != "number" ? (this.x = t.x, this.y = t.y, this.z = t.z, this) : (this.x = t, this.y = t, this.z = t, this) } copy() { return new T(this.x, this.y, this.z) } magSq() { return this.x * this.x + this.y * this.y + this.z * this.z } get mag() { return Math.hypot(this.x, this.y, this.z) } set mag(t) { this.div(this.mag).mult(t) } normalize() { let t = Math.hypot(this.x, this.y, this.z); return t === 0 ? this.set(0, 0, 0) : this.div(t) } max(t) { return this.mag > t.mag ? this : t } min(t) { return this.mag < t.mag ? this : t } equals(t) { return this.x === t.x && this.y === t.y && this.z === t.z } dist(t) { return Math.hypot(this.x - t.x, this.y - t.y, this.z - t.z) } distSq(t) { return Math.hypot(this.x - t.x, this.y - t.y, this.z - t.z) ** 2 } cross(t) { return new T(this.y * t.z - this.z * t.y, this.z * t.x - this.x * t.z, this.x * t.y - this.y * t.x) } dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z } maxMag(t) { let i = Math.hypot(this.x, this.y, this.z); return i > t ? this.div(i).mult(t) : this } minMag(t) { let i = Math.hypot(this.x, this.y, this.z); return i < t ? this.div(i).mult(t) : this } constrainMag(t, i) { let s = Math.hypot(this.x, this.y, this.z); return s < t ? this.div(s).mult(t) : s > i ? this.div(s).mult(i) : this } toArray() { return [this.x, this.y, this.z] } changeOfBasis(t = new T(1), i = new T(0, 1), s = new T(0, 0, 1)) { let n = this.x, r = this.y, a = this.z; return this.x = n * t.x + r * i.x + a * s.x, this.y = n * t.y + r * i.y + a * s.y, this.z = n * t.z + r * i.z + a * s.z, this } lerp(t, i) { const s = Math.min(Math.max(i, 0), 1); return this.x += (t.x - this.x) * s, this.y += (t.y - this.y) * s, this.z += (t.z - this.z) * s, this } angleBetween(t) { let i = this.mag * t.mag; if (i == 0) return 0; let s = this.dot(t) / i; return Math.acos(Math.max(Math.min(s, 1), -1)) } get direction() { return Math.atan2(this.y, this.x) } set direction(t) { this.x = Math.cos(t), this.y = Math.sin(t) } set direction3D(t) { this.x = Math.sin(t[1]) * Math.cos(t[0]), this.y = Math.sin(t[1]) * Math.sin(t[0]), this.z = Math.cos(t[1]) } get direction3D() { return [Math.atan2(this.y, this.x), Math.atan2(Math.hypot(this.x, this.y), this.z)] } rotate(t) { let i = Math.cos(t), s = Math.sin(t), n = this.x; return this.x = n * i + this.y * -s || 0, this.y = n * s + this.y * i || 0, this } rotateX(t) { let i = Math.cos(t), s = Math.sin(t), n = this.y; return this.y = n * i + this.z * -s || 0, this.z = n * s + this.z * i || 0, this } rotateY(t) { let i = Math.cos(t), s = Math.sin(t), n = this.x; return this.x = n * i + this.z * s || 0, this.z = n * -s + this.z * i || 0, this } } nt.Vector = T; (function (e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.createVector = e.one = e.zero = e.back = e.forward = e.down = e.up = e.left = e.right = e.scalarProyection = e.random3D = e.random2D = e.fromAngles = e.fromAngle = e.rotateY = e.rotateX = e.rotate = e.angleBetween = e.lerp = e.changeOfBasis = e.toArray = e.dot = e.cross = e.distSq = e.dist = e.equals = e.min = e.max = e.setMag = e.normalize = e.div = e.mult = e.sub = e.add = e.Vector = void 0; const t = nt; Object.defineProperty(e, "Vector", { enumerable: !0, get: function () { return t.Vector } }); const i = (h, o, g = 0, S = 0) => o instanceof t.Vector ? new t.Vector(h.x + o.x, h.y + o.y, h.z + o.z) : new t.Vector(h.x + o, h.y + g, h.z + S); e.add = i; const s = (h, o, g = 0, S = 0) => o instanceof t.Vector ? new t.Vector(h.x - o.x, h.y - o.y, h.z - o.z) : new t.Vector(h.x - o, h.y - g, h.z - S); e.sub = s; const n = (h, o) => isFinite(o) ? new t.Vector(h.x * o, h.y * o, h.z * o) : new t.Vector(h.x, h.y, h.z); e.mult = n; const r = (h, o) => { if (o !== 0 && isFinite(o)) { let g = 1 / o; return new t.Vector(h.x * g, h.y * g, h.z * g) } return new t.Vector(h.x, h.y, h.z) }; e.div = r; const a = h => (0, e.div)(h, Math.hypot(h.x, h.y, h.z)); e.normalize = a; const l = (h, o) => (0, e.div)(h, Math.hypot(h.x, h.y, h.z)).mult(o); e.setMag = l; const d = (h, o) => h.mag > o.mag ? h.copy() : o.copy(); e.max = d; const p = (h, o) => h.mag < o.mag ? h.copy() : o.copy(); e.min = p; const m = (h, o) => h.x == o.x && h.y == o.y && h.z == o.z; e.equals = m; const y = (h, o) => Math.hypot(h.x - o.x, h.y - o.y, h.z - o.z); e.dist = y; const A = (h, o) => Math.hypot(h.x - o.x, h.y - o.y, h.z - o.z) ** 2; e.distSq = A; const M = (h, o) => new t.Vector(h.y * o.z - h.z * o.y, h.z * o.x - h.x * o.z, h.x * o.y - h.y * o.x); e.cross = M; const x = (h, o) => h.x * o.x + h.y * o.y + h.z * o.z; e.dot = x; const I = h => [h.x, h.y, h.z]; e.toArray = I; const C = (h, o = new t.Vector(1), g = new t.Vector(0, 1), S = new t.Vector(0, 0, 1)) => new t.Vector(h.x * o.x + h.y * g.x + h.z * S.x, h.x * o.y + h.y * g.y + h.z * S.y, h.x * o.z + h.y * g.z + h.z * S.z); e.changeOfBasis = C; const E = (h, o, g) => new t.Vector(h.x + (o.x - h.x) * g, h.y + (o.y - h.y) * g, h.z + (o.z - h.z) * g); e.lerp = E; const G = (h, o) => { let g = h.mag * o.mag; if (g !== 0) { let S = h.dot(o) / g; return Math.acos(Math.max(Math.min(S, 1), -1)) } }; e.angleBetween = G; const D = (h, o) => { let g = Math.cos(o), S = Math.sin(o); return new t.Vector(h.x * g + h.y * -S, h.x * S + h.y * g, h.z) }; e.rotate = D; const ft = (h, o) => { let g = Math.cos(o), S = Math.sin(o); return new t.Vector(h.x, h.y * g + h.z * -S, h.y * S + h.z * g) }; e.rotateX = ft; const mt = (h, o) => { let g = Math.cos(o), S = Math.sin(o); return new t.Vector(h.x * g + h.z * S, h.y, h.x * -S + h.z * g) }; e.rotateY = mt; const ne = h => new t.Vector(Math.cos(h), Math.sin(h)); e.fromAngle = ne; const re = (h, o) => new t.Vector(Math.sin(o) * Math.cos(h), Math.sin(o) * Math.sin(h), Math.cos(o)); e.fromAngles = re; const ae = () => (0, e.fromAngle)(Math.random() * Math.PI * 2); e.random2D = ae; const he = () => (0, e.fromAngles)(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2); e.random3D = he; const le = (h, o, g) => { let S = (0, e.sub)(o, h), ze = (0, e.sub)(g, h); return S.normalize(), S.mult(ze.dot(S)), (0, e.add)(h, S) }; e.scalarProyection = le; const oe = () => new t.Vector(1, 0, 0); e.right = oe; const ue = () => new t.Vector(-1, 0, 0); e.left = ue; const de = () => new t.Vector(0, 1, 0); e.up = de; const pe = () => new t.Vector(0, -1, 0); e.down = pe; const ce = () => new t.Vector(0, 0, 1); e.forward = ce; const fe = () => new t.Vector(0, 0, -1); e.back = fe; const me = () => new t.Vector; e.zero = me; const ge = () => new t.Vector(1, 1, 1); e.one = ge; const we = (h = 0, o = 0, g = 0) => new t.Vector(h, o, g); e.createVector = we })(ke); const Ie = (e, t = 1) => e instanceof Array ? `rgba( ${e[0]}, ${e[0]}, ${e[0]}, ${e[1] || 1})` : `rgba( ${e}, ${e}, ${e}, ${t})`; function Ae(e, t) { if (!t) { e.fill(); return } e.save(), e.fillStyle = t, e.fill(), e.restore() } const xe = e => { e.clearRect(0, 0, e.canvas.width, e.canvas.height) }, Ce = (e, t, i, s = 10, n) => { e.beginPath(), e.rect(t, i, s, n || s) }; let vt = () => { }; const Oe = e => { vt = e }, Fe = e => { e.width = innerWidth, e.height = innerHeight, vt() }, Ee = e => { addEventListener("resize", () => Fe(e)) }, Ge = e => { let t = 0, i = e; for (; i instanceof Array;)t += 1, i = i[0]; return t }, W = e => { let t = [], i = e; for (; i instanceof Array;)t.push(i.length), i = i[0]; return t }, Le = (e, t, i) => Math.max(Math.min(e, i), t), Be = (e, t, i, s, n) => (e - t) / (i - t) * (n - s) + s, Wt = (e, t) => Math.random() * (t - e) + e, Bt = e => Wt(e[0], e[1]), Ne = () => { let e, t, i; do e = Math.random() * 2 - 1, t = Math.random() * 2 - 1, i = e * e + t * t; while (i >= 1 || i == 0); return e * Math.sqrt(-2 * Math.log(i) / i) }, Te = (e = 0, t = 1) => t * Ne() + e, w = e => e instanceof c ? e : new c(e, W(e)), St = e => { let t = (s, n) => { if (n[0] instanceof Array) for (let r = 0; r < n.length; r++)s[r] = [], t(s[r], n[r]); else for (let r = 0; r < n.length; r++)s[r] = n[r] }, i = w(e); if (i.data instanceof Array) { let s = []; return t(s, i.data), new c(s, i.shape) } else return new c(i.data, i.shape) }, Z = (e, t) => { if (e.length !== t.length) return !1; for (let i = 0; i < e.length; i++)if (e[i] !== t[i]) return !1; return !0 }, Ot = e => { let t = w(e), i = 1; for (let s = 0; s < t.shape.length; s++)i *= t.shape[s]; return i }, qe = (e, t) => { let i = s => { if (s[0] instanceof Array) for (let n = 0; n < s.length; n++)i(s[n]); else t(s) }; return i(e), e }, Ve = (e, t, i) => { let s = (n, r) => { if (n[0] instanceof Array) for (let a = 0; a < n.length; a++)s(n[a], r[a]); else i(n, r) }; return s(e, t), e }, q = (e, t) => { let i = s => { if (s[0] instanceof Array) for (let n = 0; n < s.length; n++)i(s[n]); else for (let n = 0; n < s.length; n++)s[n] = t(s[n]) }; return e instanceof Array ? (i(e), e) : t(e) }, U = (e, t) => { let i = (s, n) => { if (s[0] instanceof Array) for (let r = 0; r < s.length; r++)n[r] = [], i(s[r], n[r]); else for (let r = 0; r < s.length; r++)n[r] = t(s[r]) }; if (e instanceof Array) { let s = []; return i(e, s), s } return t(e) }, De = (e, t, i) => { let s = (n, r) => { if (n[0] instanceof Array) for (let a = 0; a < n.length; a++)s(n[a], r[a]); else for (let a = 0; a < n.length; a++)n[a] = i(n[a], r[a]) }; return e instanceof Array ? t instanceof Array ? (s(e, t), e) : q(e, n => i(n, t)) : t instanceof Array ? U(t, n => i(n, e)) : i(e, t) }, ve = (e, t, i) => { let s = (n, r, a) => { if (n[0] instanceof Array) for (let l = 0; l < n.length; l++)a[l] = [], s(n[l], r[l], a[l]); else for (let l = 0; l < n.length; l++)a[l] = i(n[l], r[l]) }; if (e instanceof Array) { if (t instanceof Array) { let n = []; return s(e, t, n), n } return U(e, n => i(n, t)) } else if (t instanceof Array) return U(t, n => i(n, e)); return i(e, t) }, We = (e, t) => (t = t || W(e), new c(e, t)), Nt = e => new c(e.data, e.shape), rt = (e, t = [e.length]) => { let i = 1; for (let n = 0; n < t.length; n++)i *= t[n]; if (i !== e.length) throw console.error("Based on the provided shape the tensor should have " + i + " values but has " + e.length); let s = e; for (let n = t.length - 1; n >= 0; n--) { let r = [], a = 0; for (let l = 0; l < s.length / t[n]; l++) { r[l] = []; for (let d = 0; d < t[n]; d++)r[l][d] = s[a], a++ } s = r } return s = s[0], new c(s, t) }, P = (e, t) => { let i = 1; for (let n = 0; n < e.length; n++)i *= e[n]; let s = []; for (let n = 0; n < i; n++)s[n] = t; return rt(s, e) }, Re = e => P(e, 1), z = e => P(e, 0), Rt = (e, t = W(e)) => !(e[0] instanceof Array) && t.length > 1 ? rt(e, t) : new c(e, t), Pe = (e, t) => { let i = w(e); return P(i.shape, t) }, _e = e => Pe(e, 0), at = (e, t, i) => { let s = 1, n = []; for (let r = 0; r < e.length; r++)s *= e[r]; for (let r = 0; r < s; r++)n[r] = Te(t, i); return rt(n, e) }, ht = (e, t, i) => { let s = 1, n = []; for (let r = 0; r < e.length; r++)s *= e[r]; for (let r = 0; r < s; r++)n[r] = Wt(t, i); return rt(n, e) }, Pt = e => { let t = w(e), i = []; return q(t.data, s => (i.push(s), s)), new c(i, [i.length]) }, _t = (e, t) => Ht(Pt(e), t), Ht = (e, t) => { let i = 1; for (let n = 0; n < t.length; n++)i *= t[n]; let s = w(e); if (i == s.data.length) { let n = s.data; for (let r = t.length - 1; r >= 0; r--) { let a = [], l = 0; for (let d = 0; d < n.length / t[r]; d++) { a[d] = []; for (let p = 0; p < t[r]; p++)a[d][p] = n[l], l++ } n = a } return n = n[0], new c(n, t) } else throw console.error("Based on the provided shape the tensor should have " + i + " values but has " + s.data.length) }, Jt = (e, t) => { let i = w(e); if (t.length !== i.rank) throw console.error("Dimentions in reps " + t + " does not match with the number of dimentions from tensor " + i.shape); let s = []; for (let a = 0; a < i.rank; a++)s[a] = t[a] * i.shape[a]; let n = [], r = (a, l, d) => { if (a[0] instanceof Array) for (let p = 0; p < s[d]; p++)l[p] = [], r(a[p % i.shape[d]], l[p], d + 1); else for (let p = 0; p < s[s.length - 1]; p++)l[p] = a[p % i.shape[i.rank - 1]] }; return r(i.data, n, 0), We(n, s) }, Ut = (e, t) => { let i = e.slice(), s = t.slice(); if (i.length > s.length) for (; s.length < i.length;)s.unshift(1); else for (; i.length < s.length;)i.unshift(1); let n = []; for (let r = 0; r < i.length; r++)n[r] = Math.max(i[r], s[r]); return n }, Mt = (e, t) => { let i = w(e), s = i.shape.slice(); if (t.length < i.rank) throw console.error("Rank from shape " + t.length + " is minor than tensor rank " + i.rank); let n = i; if (t.length > i.rank) { let a = s.slice(); for (; a.length < t.length;)a.unshift(1); n = _t(i, a) } let r = t.slice(); for (let a = 0; a < t.length; a++)if (n.shape[a] === t[a]) r[a] = 1; else if (n.shape[a] !== 1) throw console.error(s + " cannot be broadcast to " + t); return Jt(n, r) }, $t = e => { let t = w(e), i = t.shape.slice(); i.shift(); let s = []; for (let n = 0; n < t.data.length; n++)s[n] = new c(t.data[n], i); return s }, He = e => { let t = e.length - 1; for (; t > 0;) { let i = Math.floor(Math.random() * t + 1), s = e[t]; e[t] = e[i], e[i] = s, t -= 1 } return e }, Je = (e, t) => { let i = e.length - 1; for (; i > 0;) { let s = Math.floor(Math.random() * i + 1), n = e[i], r = t[i]; e[i] = e[s], t[i] = t[s], e[s] = n, t[s] = r, i -= 1 } return [e, t] }, B = e => (t, i) => { let s = w(t), n = w(i), r = s.shape; return Z(s.shape, n.shape) || (r = Ut(s.shape, n.shape), s = Mt(s, r), n = Mt(n, r)), new c(ve(s.data, n.data, (a, l) => e(a, l)), r) }, L = B((e, t) => e + t), O = B((e, t) => e - t), f = B((e, t) => e * t), lt = B((e, t) => e / t), b = B((e, t) => t == 0 ? 0 : e / t), Ue = B((e, t) => Math.floor(e / t)), $e = B((e, t) => Math.floor(t == 0 ? 0 : e / t)), Xe = B((e, t) => e ** t), Xt = B((e, t) => (e - t) * (e - t)), ot = e => { let t = w(e), i = -1 / 0; return q(t.data, s => (i = s > i ? s : i, s)), i }, $ = e => { let t = 0, i = 0, s = w(e); return q(s.data, n => (i++, t += n, n)), t / i }, Ft = e => { let t = w(e), i = 0; return q(t.data, s => (i += s, s)), i }, ut = e => { let t = w(e), i = 0; return q(t.data, s => (i += Math.exp(Le(s, -50, 50)), s)), i }, k = e => t => { let i = w(t), s = U(i.data, n => e(n)); return new c(s, i.shape) }, Ye = k(e => -e), dt = k(e => Math.exp(e)), j = k(e => Math.log(e)), Ke = k(e => Math.sqrt(e)), R = k(e => e * e), Qe = k(e => Math.tanh(e)), Ze = k(e => 1 - e ** 2), je = k(e => 1 / (1 + Math.exp(-e))), ti = k(e => e * (1 - e)), ei = k(e => Math.max(0, e)), ii = k(e => e > 0 ? 1 : 0), si = k(e => Math.max(.05 * e, e)), ni = k(e => e > 0 ? 1 : .05), ri = k(e => e > 0 ? e : .05 * (Math.exp(e) - 1)), ai = k(e => e > 0 ? 1 : .05 + e), hi = k(e => Math.log(1 + Math.exp(e))), li = k(e => 1 / (1 + Math.exp(-e))), oi = k(e => e > 0 ? 1 : 0), ui = e => _e(e), di = e => { let t = w(e); return $(R(O(t, $(t)))) }, pi = e => { let t = w(e), i = O(t, ot(t)); return lt(dt(i), ut(i)) }, ci = e => { let t = w(e), i = [], s = t.shape[0]; for (let n = 0; n < s; n++) { i[n] = []; for (let r = 0; r < s; r++)n == r ? i[n][r] = t.data[n] * (1 - t.data[n]) : i[n][r] = -t.data[n] * t.data[r] } return new c(i, [s, s], 2) }, Yt = (e, t) => { if (e.shape[1] !== t.shape[0]) throw console.error("Colums of A must match rows of B"); let i = []; for (let s = 0; s < e.shape[0]; s++) { i[s] = []; for (let n = 0; n < t.shape[1]; n++) { let r = 0; for (let a = 0; a < e.shape[1]; a++)r += e.data[s][a] * t.data[a][n]; i[s][n] = r } } return new c(i, [e.shape[0], t.shape[1]]) }, Kt = (e, t) => { if (e.shape[1] !== t.shape[0]) throw console.error("Colums of A must match rows of B"); let i = []; for (let s = 0; s < e.shape[0]; s++) { let n = 0; for (let r = 0; r < e.shape[1]; r++)n += e.data[s][r] * t.data[r]; i[s] = n } return new c(i, [e.shape[0]]) }, Qt = (e, t) => { if (t.shape[0] !== 1) throw console.error("Colums of A must match rows of B"); let i = []; for (let s = 0; s < e.shape[0]; s++) { i[s] = []; for (let n = 0; n < t.shape[1]; n++)i[s][n] = e.data[s] * t.data[0][n] } return new c(i, [e.shape[0], t.shape[1]]) }, Zt = (e, t) => { if (e.shape[0] !== t.shape[0]) throw console.error("Colums of A must match rows of B"); let i = 0; for (let s = 0; s < e.shape[0]; s++)i += e.data[s] * t.data[s]; return new c(i, []) }, H = (e, t) => e.rank == 2 ? t.rank == 2 ? Yt(e, t) : Kt(e, t) : t.rank == 2 ? Qt(e, t) : Zt(e, t), fi = e => { let t = w(e), i = []; for (let s = 0; s < t.shape[0]; s++) { i[s] = []; for (let n = 0, r = t.shape[1] - 1; n < r; n++, r--)i[s][n] = t.data[s][r], i[s][r] = t.data[s][n] } return new c(i, t.shape) }, mi = e => { let t = w(e), i = []; for (let s = 0; s < t.shape[1]; s++)i[s] = []; for (let s = 0; s < t.shape[1]; s++)for (let n = 0, r = t.shape[0] - 1; n < r; n++, r--)i[n][s] = t.data[r][s], i[r][s] = t.data[n][s]; return new c(i, t.shape) }, Et = (e, t) => { let i = w(e); if (t[0] == 0 && t[1] == 0) return i; let s = t[0], n = t[1], r = Math.floor(t[0] / 2), a = t[0] - r, l = Math.floor(t[1] / 2), d = t[1] - l, p = []; for (let m = 0; m < i.shape[1]; m++) { p[m] = i.data[m].slice(); for (let y = 0; y < l; y++)p[m].unshift(0); for (let y = 0; y < d; y++)p[m].push(0) } for (let m = 0; m < r; m++)p.unshift(new Array(p[0].length).fill(0)); for (let m = 0; m < a; m++)p.push(new Array(p[0].length).fill(0)); return new c(p, [i.shape[0] + s, i.shape[1] + n]) }, gi = e => { let t = w(e), i = [], s = 0, n = 0; for (let r = 0; r < t.shape[1]; r++) { i[n] = [], s = 0; for (let a = t.shape[0] - 1; a >= 0; a--)i[n][s] = t.data[a][r], s++; n++ } return new c(i, [t.shape[1], t.shape[0]]) }, jt = e => { let t = w(e), i = []; for (let s = 0; s < t.shape[0]; s++) { i[s] = t.data[s].slice(); for (let n = 0, r = t.shape[1] - 1; n < r; n++, r--)i[s][n] = t.data[s][r], i[s][r] = t.data[s][n] } for (let s = 0; s < t.shape[1]; s++)for (let n = 0, r = t.shape[0] - 1; n < r; n++, r--)i[n][s] = t.data[r][s], i[r][s] = t.data[n][s]; return new c(i, t.shape) }, wi = e => { let t = w(e), i = [], s, n = 0; for (let r = t.shape[1] - 1; r >= 0; r--) { i[n] = [], s = 0; for (let a = 0; a < t.shape[0]; a++)i[n][s] = t.data[a][r], s++; n++ } return new c(i, [t.shape[1], t.shape[0]]) }, bt = e => { let t = w(e); if (t.rank == 2) { let i = []; for (let s = 0; s < t.shape[1]; s++) { i[s] = []; for (let n = 0; n < t.shape[0]; n++)i[s][n] = t.data[n][s] } return new c(i, [t.shape[1], t.shape[0]]) } else { let i = [[]]; for (let s = 0; s < t.shape[0]; s++)i[0][s] = t.data[s]; return new c(i, [1, t.shape[0]]) } }; class c { constructor(t, i = [], s = i.length) { u(this, "data"); u(this, "shape"); u(this, "rank"); this.data = t, this.shape = i, this.rank = s } set(t) { return this.data = t.data, this.shape = t.shape, this.rank = t.rank, this } setData(t, i, s) { return this.data = t, this.shape = i || W(t), this.rank = s || this.shape.length, this } add(t) { return this.set(L(this, t)) } sub(t) { return this.set(O(this, t)) } mult(t) { return this.set(f(this, t)) } div(t) { return this.set(lt(this, t)) } divNoNan(t) { return this.set(b(this, t)) } floorDiv(t) { return this.set(Ue(this, t)) } floorDivNoNan(t) { return this.set($e(this, t)) } pow(t) { return this.set(Xe(this, t)) } sqd(t) { return this.set(Xt(this, t)) } square() { return this.set(R(this)) } sqrt() { return this.set(Ke(this)) } remap(t, i, s, n) { return this.map(r => Be(r, t, i, s, n)) } map(t) { return this.forEach(i => t(i)), this } neg() { return this.set(Ye(this)) } log() { return this.forEach(t => t == 0 ? -1e3 : Math.log(t)), this } constrain(t, i = 1) { let s, n; return t instanceof Array ? (s = t[0], n = t[1]) : (s = t, n = i), this.forEach(r => Math.max(Math.min(r, n), s)), this } exp() { return this.set(dt(this)) } dot(t) { return this.set(H(this, t)) } dotMxM(t) { return this.set(Yt(this, t)) } dotMxV(t) { return this.set(Kt(this, t)) } dotVxM(t) { return this.set(Qt(this, t)) } dotVxV(t) { return this.set(Zt(this, t)) } transpose() { return this.set(bt(this)) } mirrorHorizontally() { return this.set(fi(this)) } mirrorVertically() { return this.set(mi(this)) } rotate180() { return this.set(jt(this)) } rotate90() { return this.set(gi(this)) } rotate270() { return this.set(wi(this)) } shuffle() { return this.setData(He(this.data)) } fill(t = 0) { return this.forEach(() => t), this } size() { return Ot(this) } rangeOfValues() { let t = -1 / 0, i = 1 / 0; return this.forEach(s => (t = s > t ? s : t, i = s < i ? s : i, s)), [i, t] } shapesEqual(t) { return Z(this.shape, t) } inferShape() { return W(this.data) } inferRank() { return Ge(this.data) } copy() { return St(this) } randomize(t = []) { let i = t[0] == null ? -1 : t[0], s = t[1] == null ? 1 : t[1]; return t[2] == null ? this.forEach(() => Math.random() * (s - i) + i) : this.forEach(() => Math.floor(Math.random() * (s + 1 - i) + i)), this } mean() { return $(this) } sumExp() { return ut(this) } max() { return ot(this) } sum() { return Ft(this) } flatten() { return this.set(Pt(this)) } reshape(t) { return _t(this, t) } vectorToTensor(t) { return this.set(Ht(this, t)) } tile(t) { return this.set(Jt(this, t)) } broadcastTo(t) { return this.set(Mt(this, t)) } broadcastArgs(t) { return Ut(this.shape, t) } forEach(t) { return q(this.data, t) } forEachOfBoth(t, i) { return De(this.data, t, i) } accesLastArray(t) { return qe(this.data, t) } accesLastArrays(t, i) { return Ve(this.data, t, i) } static serialize(t) { return JSON.stringify(t) } static deserialize(t) { return typeof t == "string" && (t = JSON.parse(t)), new c(t.data, t.shape) } } const kt = (e, t, i, s) => [e[0], Math.floor((e[1] + t[0] - i[0]) / s[0] + 1), Math.floor((e[2] + t[1] - i[1]) / s[1] + 1)], It = (e, t, i, s) => { if (!t) return [0, 0]; let n = [Math.floor((e[e.length - 2] - i[0]) / s[0]) + 1, Math.floor((e[e.length - 1] - i[1]) / s[1]) + 1], r = [i[0] + (n[0] - 1) * s[0], i[1] + (n[1] - 1) * s[1]], a = [e[e.length - 2] - r[0], e[e.length - 1] - r[1]]; return [a[0] > 0 ? i[0] - a[0] : 0, a[1] > 0 ? i[1] - a[1] : 0] }, zi = (e, t, i = [2, 2], s = i, n = []) => { n = []; let r = w(e), a = t instanceof Array ? t : It(r.shape, t, i, s), l = []; for (let m = 0; m < r.shape[0]; m++)l[m] = Et(r.data[m], a).data; l = Rt(l); let d = kt(r.shape, a, i, s), p = z(d); for (let m = 0; m < l.shape[0]; m++)for (let y = 0; y < d[1]; y++)for (let A = 0; A < d[2]; A++) { let M = -1 / 0, x = []; for (let I = 0; I < i[0]; I++)for (let C = 0; C < i[1]; C++) { let E = I + y * s[0], G = C + A * s[1]; l.data[m][E][G] > M && (M = l.data[m][E][G], x = [m, E, G, y, A]) } n.push(x), p.data[m][y][A] = M } return p }, yi = (e, t, i, s, n) => { let r = [(e[0] + i[0] - n[0] * (t[0] - 1) - 1) / s[0] + 1, (e[1] + i[1] - n[1] * (t[1] - 1) - 1) / s[1] + 1]; return r = [Math.floor(r[0]), Math.floor(r[1])], r }, At = (e, t, i, s, n) => { let r = [t[0], (e[1] + i[0] - n[0] * (t[2] - 1) - 1) / s[0] + 1, (e[2] + i[1] - n[1] * (t[3] - 1) - 1) / s[1] + 1]; return r = [Math.floor(r[0]), Math.floor(r[1]), Math.floor(r[2])], r }, Si = (e, t, i, s = [1, 1]) => { i = i || s; let n = [e[e.length - 2], e[e.length - 1]], r = [t[t.length - 2], t[t.length - 1]], a = Math.floor(s[0] * (r[0] - 1) + (n[0] - 1) * (i[0] - 1)), l = Math.floor(s[1] * (r[1] - 1) + (n[1] - 1) * (i[1] - 1)); return [a, l] }, Mi = e => { let t = [e[e.length - 2], e[e.length - 1]]; return [(t[0] - 1) * 2, (t[1] - 1) * 2] }, tt = (e, t, i, s, n = [1, 1]) => i === "same" ? Si(e, t, s, n) : i === "full" ? Mi(t) : [0, 0], te = (e, t, i = [0, 0], s = [1, 1], n = [1, 1]) => { let r = w(e), a = w(t), l = i instanceof Array ? i : tt(r.shape, a.shape, i, s, n), d = yi(r.shape, a.shape, l, s, n), p = Et(r, l), m = []; for (let y = 0; y < d[0]; y++) { m[y] = []; for (let A = 0; A < d[1]; A++) { let M = 0; for (let x = 0; x < a.shape[0]; x++)for (let I = 0; I < a.shape[1]; I++) { let C = x * n[0] + y * s[0], E = I * n[1] + A * s[1]; M += p.data[C][E] * a.data[x][I] } m[y][A] = M } } return new c(m, d) }, bi = (e, t, i = [0, 0], s = [1, 1], n = [1, 1]) => { let r = jt(t); return te(e, r, i, s, n) }, ki = (e, t, i, s = [0, 0], n = [1, 1], r = [1, 1]) => { let a = w(e), l = w(t), d = w(i), p = s instanceof Array ? s : tt(a.shape, l.shape, s, n, r), m = []; for (let M = 0; M < a.shape[0]; M++)m[M] = Et(a.data[M], p).data; m = new c(m, W(m)); let y = At(a.shape, l.shape, p, n, r), A = z(y); for (let M = 0; M < l.shape[0]; M++)for (let x = 0; x < a.shape[0]; x++)for (let I = 0; I < y[1]; I++)for (let C = 0; C < y[2]; C++) { let E = 0; for (let G = 0; G < l.shape[2]; G++)for (let D = 0; D < l.shape[3]; D++) { let ft = G * r[0] + I * n[0], mt = D * r[1] + C * n[1]; E += m.data[x][ft][mt] * l.data[M][x][G][D] } A.data[M][I][C] += E + d.data[M][I][C] / y[0] } return A }, V = (e, t) => f(e, t), Ii = (e, t) => H(t, e), Ai = { forward: e => e, backward: e => Re(e.shape), updateError: e => e, name: "linear" }, Tt = { forward: e => je(e), backward: e => ti(e), updateError: V, name: "sigmoid" }, xi = { forward: e => ei(e), backward: e => ii(e), updateError: V, name: "relu" }, Ci = { forward: e => si(e), backward: e => ni(e), updateError: V, name: "leakyrelu" }, Oi = { forward: e => ri(e), backward: e => ai(e), updateError: V, name: "elu" }, Fi = { forward: e => hi(e), backward: e => li(e), updateError: V, name: "softplus" }, Ei = { forward: e => oi(e), backward: e => ui(e), updateError: V, name: "binarystep" }, Gi = { forward: e => Qe(e), backward: e => Ze(e), updateError: V, name: "tanh" }, Li = { forward: e => pi(e), backward: e => ci(e), updateError: Ii, name: "softmax" }, Bi = e => { switch (e) { case "linear": return Ai; case "sigmoid": return Tt; case "relu": return xi; case "leakyrelu": return Ci; case "elu": return Oi; case "softplus": return Fi; case "binarystep": return Ei; case "tanh": return Gi; case "softmax": return Li; default: return Tt } }, _ = e => { e.map(s => Math.floor(s)); let t = 1, i = 1; if (e.length == 2) t = e[1], i = e[0]; else if (e.length == 4) { let s = e[2] * e[3]; t = s * e[1], i = s * e[0] } return [t, i] }, Ni = (e, t = 0) => P(e, t), Ti = e => P(e, 1), qi = e => P(e, 0), qt = (e, t, i) => { let s = _(e)[0] || 1; s = 1 / Math.sqrt(s); let n = t || -s; return ht(e, n, i || s) }, Vi = (e, t = 0, i = 1) => at(e, t, i), Di = e => { let t = _(e), i = t[0] || 1, s = t[1] || 1, n = Math.sqrt(6) / Math.sqrt(i + s); return ht(e, -n, n) }, vi = e => { let t = _(e), i = t[0] || 1, s = t[1] || 1, n = Math.sqrt(2 / (i + s)); return at(e, 0, n) }, Wi = e => { let i = _(e)[0] || 1, s = Math.sqrt(6 / i); return ht(e, -s, s) }, Ri = e => { let i = _(e)[0] || 1, s = Math.sqrt(2 / i); return at(e, 0, s) }, Pi = (e, t = 1, i = "fan_out", s = "uniform") => { let n = _(e), r = n[0] || 1, a = n[1] || 1, l = r; if (i == "fan_out" ? l = a : i == "avg" && (l = (r + a) / 2), s == "uniform") { let p = Math.sqrt(3 * t / l); return ht(e, -p, p) } let d = Math.sqrt(t / l); return at(e, 0, d) }, N = e => { switch (e) { case "constant": return Ni; case "ones": return Ti; case "zeros": return qi; case "randomUniform": return qt; case "randomNormal": return Vi; case "xavierUniform": return Di; case "xavierNormal": return vi; case "heUniform": return Wi; case "heNormal": return Ri; case "varianceScaling": return Pi; default: return qt } }, _i = (e, t) => $(Xt(t, e)), Hi = (e, t) => lt(f(2, O(e, t)), Ot(e)), Ji = (e, t) => -Ft(f(t, j(e))), Ui = (e, t) => f(t, b(-1, e)), $i = (e, t) => { let i = O(e, ot(e)), s = lt(dt(i), ut(i)); return -Ft(f(t, j(s))) }, Xi = (e, t) => { let i = O(e, ot(e)), s = b(dt(i), ut(i)); return O(s, t) }, Yi = (e, t) => { let i = f(t, j(e)), s = O(1, t), n = j(O(1, e)), r = L(i, f(s, n)); return -$(r) }, Ki = (e, t) => { let i = b(O(1, t), O(1, e)), s = b(t, e), n = O(i, s); return b(n, Ot(n)) }, Vt = { forward: _i, backward: Hi }, Qi = { forward: Ji, backward: Ui }, Zi = { forward: $i, backward: Xi }, ji = { forward: Yi, backward: Ki }, gt = e => { switch (e) { case "mse": return Vt; case "crossEntropy": return Qi; case "softmaxCrossEntropy": return Zi; case "binaryCrossEntropy": return ji; default: return Vt } }; class pt { constructor() { u(this, "args"); u(this, "name"); this.args = [], this.name = "" } apply(t, i = 0) { return f(t[0], i) } } class ts extends pt { constructor(t) { super(), this.name = "sgd", this.args = t } apply(t) { return f(t[0], this.args[0]) } } const et = (e = .1) => new ts([e]); class es extends pt { constructor(t) { super(), this.name = "momentum", this.args = t } apply(t) { return t[1] == null ? f(f(t[0], 1 - this.args[1]), this.args[0]) : (t[1] = f(t[1], this.args[1]).add(f(t[0], 1 - this.args[1])), f(t[1], this.args[0])) } } const is = (e = .1, t = .9) => new es([e, t]); class ss extends pt { constructor(t) { super(), this.name = "rmsprop", this.args = t } apply(t) { if (t[1] == null) { let i = f(R(t[0]), 1 - this.args[1]); return f(b(t[0], L(i, this.args[2]).sqrt()), this.args[0]) } else return t[1] = f(t[1], this.args[1]).add(f(R(t[0]), 1 - this.args[1])), f(b(t[0], L(t[1], this.args[2]).sqrt()), this.args[0]) } } const ns = (e = .01, t = .9, i = 1e-7) => new ss([e, t, i]); class rs extends pt { constructor(t) { super(), this.name = "adam", this.args = t } apply(t, i = 0) { if (t[1] == null) { let s = f(t[0], 1 - this.args[1]), n = f(R(t[0]), 1 - this.args[2]), r = b(s, 1 - this.args[1]), a = b(n, 1 - this.args[2]); return f(b(r, L(a, this.args[3]).sqrt()), this.args[0]) } else { t[1] = L(f(t[1], this.args[1]), f(t[0], 1 - this.args[1])), t[2] = L(f(t[2], this.args[2]), f(R(t[0]), 1 - this.args[2])); let s = b(t[1], 1 - this.args[1] ** i), n = b(t[2], 1 - this.args[2] ** i); return f(b(s, L(n, this.args[3]).sqrt()), this.args[0]) } } } const ee = (e = .1, t = .9, i = .999, s = 1e-7) => new rs([e, t, i, s]), as = e => { switch (e.name) { case "sgd": return et(...e.args); case "momentum": return is(...e.args); case "rmsprop": return ns(...e.args); case "adam": return ee(...e.args); default: return et() } }; class X { constructor() { u(this, "input"); u(this, "type"); u(this, "isTrainable"); u(this, "name"); u(this, "output"); this.input = [new c([])], this.output = [new c([])], this.type = "", this.name = "", this.isTrainable = !1 } forward(t) { return t } backward(t) { return t } serialize() { return JSON.stringify(this) } } class ct extends X { constructor() { super(); u(this, "weights"); u(this, "bias"); u(this, "weightsGradient"); u(this, "biasGradient"); u(this, "biasConstrain"); u(this, "weightsConstrain"); u(this, "optimizerWeights"); u(this, "optimizerBias"); u(this, "weightsInitializer"); u(this, "weightsInitializerFunction"); u(this, "biasInitializer"); u(this, "biasInitializerFunction"); u(this, "parameters"); this.name = this.type, this.weights = new c([]), this.bias = new c([]), this.weightsConstrain = [-1e7, 1e7], this.biasConstrain = [-1e7, 1e7], this.weightsGradient = new c([]), this.biasGradient = new c([]), this.optimizerWeights = [this.weightsGradient], this.optimizerBias = [this.weightsGradient], this.weightsInitializer = "xavierNormal", this.weightsInitializerFunction = N(this.weightsInitializer), this.biasInitializer = "zeros", this.biasInitializerFunction = N(this.biasInitializer), this.parameters = 0 } reshapeOptimizerParameters() { this.weightsGradient = z(this.weights.shape), this.biasGradient = z(this.bias.shape), this.optimizerWeights = [this.weightsGradient, z(this.weights.shape), z(this.weights.shape)], this.optimizerBias = [this.biasGradient, z(this.bias.shape), z(this.bias.shape)] } update(i, s = 1, n = 0) { this.weightsGradient.divNoNan(s), this.biasGradient.divNoNan(s); let r = i.apply(this.optimizerWeights, n), a = i.apply(this.optimizerBias, n); this.weights.sub(r), this.bias.sub(a), this.weights.constrain(this.weightsConstrain), this.bias.constrain(this.biasConstrain), this.weightsGradient.mult(0), this.biasGradient.mult(0) } setParameters(i) { this.setWeights(Nt(i.weights)), this.setBias(Nt(i.bias)) } setWeights(i) { let s = St(i); if (!Z(s.shape, this.weights.shape)) throw "Weights shapes don't match"; this.weights = s } getWeights() { return this.weights.copy() } setBias(i) { let s = St(i); if (!Z(s.shape, this.bias.shape)) throw "Bias shapes don't match"; this.bias = s } getBias() { return this.bias.copy() } mutate(i = .1, s) { this.mutateWeights(i, s), this.mutateBias(i, s) } mutateWeights(i, s) { this.weights.map(n => Math.random() < i ? Bt(s) : n) } mutateBias(i, s) { this.bias.map(n => Math.random() < i ? Bt(s) : n) } save() { return { weights: this.getWeights(), bias: this.getBias() } } } class xt extends ct { constructor(i) { super(); u(this, "units"); u(this, "outputShape"); u(this, "inputShape"); this.type = "dense", this.isTrainable = !0, this.units = Math.floor(i.units), this.outputShape = this.units, this.weightsInitializer = i.weightsInitializer || "xavierNormal", this.weightsInitializerFunction = N(this.weightsInitializer), this.biasInitializer = i.biasInitializer || "zeros", this.biasInitializerFunction = N(this.biasInitializer), this.inputShape = i.inputShape ? Math.floor(i.inputShape) : 1, this.weights = this.weightsInitializerFunction([this.units, this.inputShape]), this.bias = this.biasInitializerFunction([this.units]), this.weightsConstrain = i.weightsConstrain || [-1e7, 1e7], this.biasConstrain = i.biasConstrain || [-1e7, 1e7], this.weightsGradient = z(this.weights.shape), this.biasGradient = z(this.bias.shape), this.optimizerWeights = [this.weightsGradient, z(this.weights.shape), z(this.weights.shape)], this.optimizerBias = [this.biasGradient, z(this.bias.shape), z(this.bias.shape)], this.parameters = this.units * this.inputShape + this.outputShape, i.weights !== void 0 && this.setParameters(i) } resize(i) { this.inputShape = i instanceof Array ? i[0] : i, this.weights = this.weightsInitializerFunction([this.units, this.inputShape]), this.bias = this.biasInitializerFunction([this.units]), this.reshapeOptimizerParameters(), this.parameters = this.units * this.inputShape + this.outputShape } forward(i) { this.input = i; for (let s = 0; s < this.input.length; s++)this.output[s] = H(this.weights, this.input[s]).add(this.bias); return this.output } backward(i) { let s = bt(this.weights), n = []; for (let r = 0; r < i.length; r++) { let a = i[r], l = bt(this.input[r]), d = H(a, l); this.weightsGradient.add(d), this.biasGradient.add(a), n[r] = H(s, a) } return n } save() { return { type: this.type, weights: this.weights, bias: this.bias, weightsInitializer: this.weightsInitializer, biasInitializer: this.biasInitializer, inputShape: this.inputShape, units: this.units, outputShape: this.outputShape, weightsConstrain: this.weightsConstrain, biasConstrain: this.biasConstrain } } } class hs extends ct { constructor(i) { super(); u(this, "filters"); u(this, "padding"); u(this, "kernelSize"); u(this, "inputShape"); u(this, "stride"); u(this, "dilation"); u(this, "kernelShape"); u(this, "padAmt"); u(this, "kernelGradientPad"); u(this, "inputGradientPad"); u(this, "outputShape"); this.type = "conv", this.name = this.type, this.isTrainable = !0, this.filters = Math.floor(i.filters), this.padding = i.padding || "valid", i.weightsConstrain && (this.weightsConstrain = i.weightsConstrain), i.biasConstrain && (this.biasConstrain = i.biasConstrain), this.weightsInitializer = i.weightsInitializer || "xavierNormal", this.weightsInitializerFunction = N(this.weightsInitializer), this.biasInitializer = i.biasInitializer || "zeros", this.biasInitializerFunction = N(this.biasInitializer), this.kernelSize = typeof i.kernelSize == "number" ? this.kernelSize = [i.kernelSize, i.kernelSize] : [i.kernelSize[0], i.kernelSize[1]], this.kernelSize.map(s => Math.floor(s)), this.stride = [1, 1], i.stride && (this.stride = i.stride instanceof Array ? i.stride : [i.stride, i.stride], this.stride.map(s => Math.floor(s))), this.dilation = [1, 1], i.dilation && (this.dilation = i.dilation instanceof Array ? i.dilation : [i.dilation, i.dilation], this.dilation.map(s => Math.floor(s))), this.kernelGradientPad = "valid", this.inputGradientPad = "full", this.padding == "same" && (this.kernelGradientPad = [this.kernelSize[0] - 1, this.kernelSize[1] - 1], this.inputGradientPad = "same"), this.inputShape = i.inputShape ? i.inputShape.slice() : [1, 1, 1], this.inputShape.map(s => Math.floor(s)), this.kernelShape = [this.filters, this.inputShape[0], this.kernelSize[0], this.kernelSize[1]], this.padAmt = tt(this.inputShape, this.kernelShape, this.padding, this.stride, this.dilation), this.outputShape = At(this.inputShape, this.kernelShape, this.padAmt, this.stride, this.dilation), this.weights = this.weightsInitializerFunction(this.kernelShape), this.bias = this.biasInitializerFunction(this.outputShape), this.weightsGradient = z(this.weights.shape), this.biasGradient = z(this.bias.shape), this.optimizerWeights = [this.weightsGradient, z(this.weights.shape), z(this.weights.shape)], this.optimizerBias = [this.biasGradient, z(this.bias.shape), z(this.bias.shape)], this.parameters = this.weights.size() + this.bias.size(), i.weights !== void 0 && this.setParameters(i) } resize(i) { this.inputShape = i instanceof Array ? i : [1, 1, 1], this.inputShape.map(s => Math.floor(s)), this.kernelShape = [this.filters, this.inputShape[0], this.kernelSize[0], this.kernelSize[1]], this.padAmt = tt(this.inputShape, this.kernelShape, this.padding, this.stride, this.dilation), this.outputShape = At(this.inputShape, this.kernelShape, this.padAmt, this.stride, this.dilation), this.weights = this.weightsInitializerFunction(this.kernelShape), this.bias = this.biasInitializerFunction(this.outputShape), this.weightsGradient = z(this.weights.shape), this.biasGradient = z(this.bias.shape), this.optimizerWeights = [this.weightsGradient, z(this.weights.shape), z(this.weights.shape)], this.optimizerBias = [this.biasGradient, z(this.bias.shape), z(this.bias.shape)], this.parameters = this.weights.size() + this.bias.size() } forward(i) { this.input = i; for (let s = 0; s < this.input.length; s++)this.output[s] = ki(this.input[s], this.weights, this.bias, this.padAmt, this.stride, this.dilation); return this.output } backward(i) { let s = i, n = []; for (let r = 0; r < i.length; r++) { n[r] = z(this.inputShape); let a = []; for (let l = 0; l < this.kernelShape[0]; l++) { a[l] = []; for (let d = 0; d < this.kernelShape[1]; d++) { a[l][d] = te(this.input[r].data[d], s[r].data[l], this.kernelGradientPad).data; let p = bi(s[r].data[l], this.weights.data[l][d], this.inputGradientPad); n[r].data[d] = L(n[r].data[d], p).data } } a = new c(a, this.kernelShape), this.weightsGradient.add(a), this.biasGradient.add(s[r]) } return n } save() { return { type: this.type, filters: this.filters, padding: this.padding, weightsInitializer: this.weightsInitializer, biasInitializer: this.biasInitializer, kernelSize: this.kernelSize, inputShape: this.inputShape, stride: this.stride, dilation: this.dilation, weightsConstrain: this.weightsConstrain, biasConstrain: this.biasConstrain, weights: this.weights, bias: this.bias } } } class ls extends X { constructor(i = {}) { super(); u(this, "inputShape"); u(this, "outputShape"); this.type = "flatten", this.inputShape = i.inputShape instanceof Array ? i.inputShape.slice() : [1, 1, 1], this.inputShape.map(s => Math.floor(s)), this.outputShape = 1; for (let s = 0; s < this.inputShape.length; s++)this.outputShape *= this.inputShape[s] } resize(i) { this.inputShape = i instanceof Array ? i.slice() : [1, 1, 1], this.inputShape.map(s => Math.floor(s)), this.outputShape = 1; for (let s = 0; s < this.inputShape.length; s++)this.outputShape *= this.inputShape[s] } forward(i) { this.input = i; let s = []; for (let n = 0; n < i.length; n++) { let r = []; i[n].forEach(a => (r.push(a), a)), s[n] = new c(r, [this.outputShape]) } return s } backward(i) { let s = []; for (let n = 0; n < i.length; n++) { let r = [], a = 0; for (let l = 0; l < this.inputShape[0]; l++) { r[l] = []; for (let d = 0; d < this.inputShape[1]; d++) { r[l][d] = []; for (let p = 0; p < this.inputShape[2]; p++)r[l][d][p] = i[n].data[a], a++ } } s[n] = new c(r, this.inputShape) } return s } serialize() { return JSON.stringify(this) } save() { return { type: this.type, inputShape: this.inputShape } } } class os extends X { constructor(i = {}) { super(); u(this, "rate"); u(this, "inputShape"); u(this, "outputShape"); this.type = "dropout", this.rate = i.rate || .1, this.inputShape = i.inputShape ? i.inputShape : 1, this.outputShape = this.inputShape } resize(i) { this.inputShape = i, this.outputShape = this.inputShape } forward(i) { this.input = i; let s = []; for (let n = 0; n < i.length; n++)s[n] = new c(U(i[n].data, r => Math.random() < this.rate ? 0 : r), i[n].shape); return s } backward(i) { return i } serialize() { return JSON.stringify(this) } save() { return { type: this.type, rate: this.rate, inputShape: this.inputShape } } } class us extends ct { constructor(i = {}) { super(); u(this, "inputShape"); u(this, "internInputShape"); u(this, "norm"); u(this, "xmu"); u(this, "variance"); u(this, "outputShape"); this.type = "norm", this.isTrainable = !0, this.inputShape = 1, i.inputShape instanceof Array && (this.inputShape = i.inputShape.slice().map(s => Math.floor(s))), typeof i.inputShape == "number" && (this.inputShape = Math.floor(i.inputShape)), this.outputShape = this.inputShape, this.internInputShape = this.inputShape instanceof Array ? this.inputShape.slice().map(s => Math.floor(s)) : [Math.floor(this.inputShape)], this.weightsInitializer = i.weightsInitializer || "xavierNormal", this.weightsInitializerFunction = N(this.weightsInitializer), this.biasInitializer = i.biasInitializer || "zeros", this.biasInitializerFunction = N(this.biasInitializer), this.weights = this.weightsInitializerFunction(this.internInputShape), this.bias = this.biasInitializerFunction(this.internInputShape), this.reshapeOptimizerParameters(), this.norm = new c([]), this.xmu = new c([]), this.variance = 0, i.weights !== void 0 && this.setParameters(i) } resize(i) { this.inputShape = i instanceof Array ? i.slice().map(s => Math.floor(s)) : Math.floor(i), this.outputShape = this.inputShape, this.internInputShape = i instanceof Array ? i.slice().map(s => Math.floor(s)) : [Math.floor(i)], this.weights = this.weightsInitializerFunction(this.internInputShape), this.bias = this.biasInitializerFunction(this.internInputShape), this.reshapeOptimizerParameters(), this.parameters = this.weights.size() + this.bias.size() } forward(i) { this.input = i; for (let s = 0; s < i.length; s++) { this.xmu = O(this.input[s], this.input[s].mean()), this.variance = di(this.input[s]) + 1e-7, this.norm = b(this.xmu, this.variance ** .5); let n = f(this.weights, this.norm).add(this.bias); this.output[s] = n } return this.output } backward(i) { let s = []; for (let n = 0; n < i.length; n++) { let r = this.output[n], a = f(r, this.norm); this.weightsGradient.add(a), this.biasGradient.add(r); let l = 1 / this.variance ** .5; s[n] = f(r, this.weights); let d = f(s[n], this.xmu).mult(-.5).mult(this.variance ** (-3 / 2)), p = f(s[n], -l).add(f(d, b(1 / i.length, f(this.xmu, -2)))); s[n] = f(s[n], l).add(L(b(p, i.length), b(f(d, 2 / i.length), this.xmu))) } return s } save() { return { type: this.type, inputShape: this.inputShape, weights: this.weights, bias: this.bias, weightsInitializer: this.weightsInitializer, biasInitializer: this.biasInitializer } } } class ie extends X { constructor(i) { super(); u(this, "forwardedInput"); u(this, "inputShape"); u(this, "outputShape"); u(this, "activation"); this.isTrainable = !1, this.type = "activation", this.name = i.name, this.activation = i, this.inputShape = 0, this.outputShape = this.inputShape, this.forwardedInput = [new c([])] } resize(i) { this.inputShape = i, this.outputShape = this.inputShape } forward(i) { this.input = i; for (let s = 0; s < i.length; s++)this.forwardedInput[s] = this.activation.forward(i[s]); return this.forwardedInput } backward(i) { let s = []; for (let n = 0; n < i.length; n++)s[n] = this.activation.updateError(i[n], this.activation.backward(this.forwardedInput[n])); return s } serialize() { return JSON.stringify(this) } save() { return { type: this.type, name: this.name, inputShape: this.inputShape } } } class ds extends X { constructor(i = {}) { super(); u(this, "poolSize"); u(this, "stride"); u(this, "padding"); u(this, "padAmt"); u(this, "inputShape"); u(this, "coords"); u(this, "outputShape"); this.type = "maxpooling", this.poolSize = [2, 2], i.poolSize && (this.poolSize = i.poolSize instanceof Array ? i.poolSize : [i.poolSize, i.poolSize], this.poolSize.map(s => Math.floor(s))), this.stride = this.poolSize, i.stride && (this.stride = i.stride instanceof Array ? i.stride : [i.stride, i.stride], this.stride.map(s => Math.floor(s))), this.padding = i.padding || !1, this.inputShape = i.inputShape ? i.inputShape.slice() : [1, 1, 1], this.inputShape.map(s => Math.floor(s)), this.padAmt = It(this.inputShape, this.padding, this.poolSize, this.stride), this.outputShape = kt(this.inputShape, this.padAmt, this.poolSize, this.stride), this.coords = i.coords ? i.coords.slice() : [] } resize(i) { this.inputShape = i instanceof Array ? i.slice() : [1, 1, 1], this.inputShape.map(s => Math.floor(s)), this.padAmt = It(this.inputShape, this.padding, this.poolSize, this.stride), this.outputShape = kt(this.inputShape, this.padAmt, this.poolSize, this.stride) } forward(i) { this.input = i; let s = []; for (let n = 0; n < i.length; n++)this.coords[n] = [], s[n] = zi(this.input[n], this.padding, this.poolSize, this.stride, this.coords[n]); return s } backward(i) { let s = []; for (let n = 0; n < this.input.length; n++) { s[n] = z(this.inputShape); for (let r = 0; r < this.coords[n].length; r++)s[n].data[this.coords[n][r][0]][this.coords[n][r][1]][this.coords[n][r][2]] = i[n].data[this.coords[n][r][0]][this.coords[n][r][3]][this.coords[n][r][4]] } return s } save() { return { type: this.type, poolSize: this.poolSize, stride: this.stride, padding: this.padding, inputShape: this.inputShape, coords: this.coords } } } const ps = e => { switch (e) { case "dense": return xt; case "conv": return hs; case "maxpooling": return ds; case "flatten": return ls; case "dropout": return os; case "norm": return us; case "activation": return ie; default: return xt } }, cs = e => { let t = ps(e.type); return new t(e) }, wt = e => new xt(e), Y = e => { const t = Bi(e); return new ie(t) }; class J { constructor() { u(this, "layers"); u(this, "numLayers"); u(this, "trainableLayers"); u(this, "error"); u(this, "loss"); u(this, "lossFunction"); u(this, "optimizer"); u(this, "parameters"); u(this, "batch"); u(this, "batchSize"); this.batch = 0, this.parameters = 0, this.layers = [], this.numLayers = 0, this.loss = "mse", this.lossFunction = gt(this.loss), this.trainableLayers = [], this.error = 1, this.optimizer = et(.1), this.batchSize = 0 } setLossFunction(t) { this.loss = t, this.lossFunction = gt(this.loss) } compile(t) { this.optimizer = t.optimizer || et(.1), this.loss = t.loss || "mse", this.lossFunction = gt(this.loss) } add(t, i = !1) { if (this.numLayers > 0 && i == !1) { let s = this.layers[this.numLayers - 1].outputShape; t.resize(s) } t instanceof ct && (this.trainableLayers.push(t), this.parameters += t.parameters), this.layers.push(t), this.numLayers++ } async predictOnBatch(t) { let i = t; for (let s = 0; s < this.numLayers; s++)i = this.layers[s].forward(i); return i } async predict(t) { return (await this.predictOnBatch([t]))[0] } async train(t, i, s = { epochs: 1, batchSize: 1, shuffle: !1 }) { let n = s.shuffle || !1, r = s.epochs || 1; this.batchSize = s.batchSize || t.length; for (let a = 0; a < r; a++)for (let l = 0; l < t.length / this.batchSize; l++) { let d = t.slice(l, l + this.batchSize), p = i.slice(l, l + this.batchSize); await this.trainOnBatch(d, p, n) } this.batch > t.length / this.batchSize && (this.batch = 0) } async trainOnBatch(t, i, s = !1) { let n = t.length; this.batchSize == 0 && (this.batchSize = n), s && Je(t, i); let r = 0, a = await this.predictOnBatch(t), l = []; for (let d = 0; d < n; d++)r += this.lossFunction.forward(a[d], i[d]), l[d] = this.lossFunction.backward(a[d], i[d]); for (let d = this.numLayers - 1; d >= 0; d--)l = this.layers[d].backward(l); this.batch++, r /= n, this.error = r, this.update(this.batch) } update(t) { for (let i = 0; i < this.trainableLayers.length; i++)this.trainableLayers[i].update(this.optimizer, this.batchSize, t) } mutateRandomLayer(t = !1, i = .1, s = .1) { let n = Math.floor(Math.random() * this.trainableLayers.length), r = [-s, s]; this.trainableLayers[n].mutateWeights(i, r), t != !1 && this.trainableLayers[n].mutateBias(i, r) } mutate(t = !1, i = .1, s = .5) { let n = [-s, s]; for (let r = 0; r < this.trainableLayers.length; r++)this.trainableLayers[r].mutateWeights(i, n), t != !1 && this.trainableLayers[r].mutateBias(i, n) } save() { let t = []; for (let i = 0; i < this.layers.length; i++)t.push(this.layers[i].save()); return JSON.stringify({ loss: this.loss, optimizer: this.optimizer, layers: t }) } static loadModel(t) { let i = new J; for (let s = 0; s < t.layers.length; s++) { let n; t.layers[s].type == "activation" ? (n = Y(t.layers[s].name), i.add(n)) : (n = cs(t.layers[s]), i.add(n, !0)) } return i.compile({ loss: t.loss, optimizer: as(t.optimizer) }), i } copy() { return J.loadModel(JSON.parse(this.save())) } static copy(t) { return J.loadModel(JSON.parse(t.save())) } } let it = document.querySelector("canvas"), zt = it.getContext("2d"), v, st, K, Q, fs = $t([[0, 0], [0, 1], [1, 0], [1, 1]]), ms = $t([[0], [1], [1], [0]]), F; function Gt() { F = new J, F.add(wt({ inputShape: 2, units: 3 })), F.add(Y("tanh")), F.add(wt({ units: 2 })), F.add(Y("tanh")), F.add(wt({ units: 1 })), F.add(Y("tanh")), F.compile({ loss: "mse", optimizer: ee() }) } Gt(); Ee(it); function se() { it.width = innerWidth, it.height = innerHeight, v = Math.min(innerHeight, innerWidth) / 25, Q = Math.round(innerWidth / v), K = Math.round(innerHeight / v), st = []; for (let t = 0; t < Q; t++)for (let i = 0; i < K; i++) { let s = t / Q, n = i / K; st.push(Rt([s, n])) } } se(); Oe(se); let yt; Ct.animate(async () => { xe(zt), await F.train(fs, ms, { shuffle: !0, batchSize: 1, epochs: 3 }), yt = []; let e = await F.predictOnBatch(st); for (let i = 0; i < st.length; i++)yt[i] = e[i].data[0]; let t = 0; for (let i = 0; i < Q; i++)for (let s = 0; s < K; s++) { let n = Ie(yt[t] * 255); Ce(zt, i * v, s * v, v), Ae(zt, n), t++ } }); Dt(); addEventListener("dblclick", Gt); setInterval(() => { F.error > .01 && Gt() }, 3e3);
