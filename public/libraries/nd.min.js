var Ms = Object.defineProperty; var ks = (h, A, V) => A in h ? Ms(h, A, { enumerable: !0, configurable: !0, writable: !0, value: V }) : h[A] = V; var u = (h, A, V) => (ks(h, typeof A != "symbol" ? A + "" : A, V), V); (function (h, A) { typeof exports == "object" && typeof module != "undefined" ? A(exports) : typeof define == "function" && define.amd ? define(["exports"], A) : (h = typeof globalThis != "undefined" ? globalThis : h || self, A(h.nd = {})) })(this, function (h) { "use strict"; const A = (s, t, e) => Math.max(Math.min(s, e), t), V = (s, t, e, i, a) => (s - t) / (e - t) * (a - i) + i, Ue = (s, t = 1) => Math.floor(typeof s == "number" ? Math.random() * (t - s) + s : Math.random() * (s[1] - s[0]) + s[0]), H = (s, t = 1) => typeof s == "number" ? Math.random() * (t - s) + s : Math.random() * (s[1] - s[0]) + s[0], Qt = (s = 0, t = 1) => { let e, i, a; do e = Math.random() * 2 - 1, i = Math.random() * 2 - 1, a = e * e + i * i; while (a >= 1 || a == 0); let r = e * Math.sqrt(-2 * Math.log(a) / a); return t * r + s }, We = () => { let s, t, e; do s = Math.random() * 2 - 1, t = Math.random() * 2 - 1, e = s * s + t * t; while (e >= 1 || e == 0); return s * Math.sqrt(-2 * Math.log(e) / e) }; var xe = Object.freeze({ __proto__: null, [Symbol.toStringTag]: "Module", constrain: A, map: V, randomInt: Ue, randomRange: H, randomNormal: Qt, randomStdNorm: We }); const Y = s => new p(s.data, s.shape), D = (s, t = [s.length]) => { let e = 1; for (let a = 0; a < t.length; a++)e *= t[a]; if (e !== s.length) throw console.error("Based on the provided shape the tensor should have " + e + " values but has " + s.length); let i = s; for (let a = t.length - 1; a >= 0; a--) { let r = [], n = 0; for (let l = 0; l < i.length / t[a]; l++) { r[l] = []; for (let o = 0; o < t[a]; o++)r[l][o] = i[n], n++ } i = r } return i = i[0], new p(i, t) }, At = (s, t) => (t = t || _(s), new p(s, t)), Je = s => new p(s, [], 0), Et = (s, t = _(s)) => !(s[0] instanceof Array) && t.length > 1 ? D(s, t) : new p(s, t), He = (s, t = _(s)) => !(s[0] instanceof Array) && t.length > 1 ? D(s, t) : new p(s, t), Xe = s => { let t = []; for (let e = 0; e < s[0]; e++) { t[e] = []; for (let i = 0; i < s[1]; i++)t[e][i] = e == i ? 1 : 0 } return new p(t, s) }, mt = (s, t = 0) => { let e = 1; for (let a = 0; a < s.length; a++)e *= s[a]; let i = []; for (let a = 0; a < e; a++)i[a] = t; return D(i, s) }, y = s => { let t = 1; for (let i = 0; i < s.length; i++)t *= s[i]; let e = []; for (let i = 0; i < t; i++)e[i] = 0; return D(e, s) }, Ze = s => { let t = w(s), e = 1; for (let a = 0; a < t.rank; a++)e *= t.shape[a]; let i = []; for (let a = 0; a < e; a++)i[a] = 0; return D(i, t.shape) }, Yt = s => { let t = 1; for (let i = 0; i < s.length; i++)t *= s[i]; let e = []; for (let i = 0; i < t; i++)e[i] = 1; return D(e, s) }, Ke = s => { let t = w(s), e = 1; for (let a = 0; a < t.rank; a++)e *= t.shape[a]; let i = []; for (let a = 0; a < e; a++)i[a] = 1; return D(i, t.shape) }, Qe = (s, t) => { if (typeof s == "number") { let n = y([t]); return n.data instanceof Array && n.data[s] !== void 0 && (n.data[s] = 1), n } let e = w(s), i = e.shape.slice(); i.push(t); let a = y(i), r = 0; return a.accesLastArray(n => { let l = e.data[r]; n[l] !== void 0 && (n[l] = 1), r++ }), a }, Ye = (s, t, e = 1) => { let i = []; if (e = Math.abs(e), s < t) for (; s < t;)i.push(s), s += e; else for (; s < t;)i.push(s), s -= e; return new p(i, [i.length]) }, $ = (s, t, e) => { let i = 1, a = []; for (let r = 0; r < s.length; r++)i *= s[r]; for (let r = 0; r < i; r++)a[r] = H(t, e); return D(a, s) }, j = (s, t, e) => { let i = 1, a = []; for (let r = 0; r < s.length; r++)i *= s[r]; for (let r = 0; r < i; r++)a[r] = Qt(t, e); return D(a, s) }, _ = s => { let t = [], e = s; for (; e instanceof Array;)t.push(e.length), e = e[0]; return t }, $e = s => { let t = 0, e = s; for (; e instanceof Array;)t += 1, e = e[0]; return t }, w = s => s instanceof p ? s : new p(s, _(s)), je = s => { let t = s.length - 1; for (; t > 0;) { let e = Math.floor(Math.random() * t + 1), i = s[t]; s[t] = s[e], s[e] = i, t -= 1 } return s }, $t = (s, t) => { let e = s.length - 1; for (; e > 0;) { let i = Math.floor(Math.random() * e + 1), a = s[e], r = t[e]; s[e] = s[i], t[e] = t[i], s[i] = a, t[i] = r, e -= 1 } return [s, t] }, Tt = s => { let t = w(s), e = 1; for (let i = 0; i < t.shape.length; i++)e *= t.shape[i]; return e }, gt = (s, t) => { if (s.length !== t.length) return !1; for (let e = 0; e < s.length; e++)if (s[e] !== t[e]) return !1; return !0 }, ti = (s, t) => { if (s.length !== t.length) return !1; for (let e = 0; e < s.length; e++)if (s[e] !== t[e]) return !1; return !0 }, ei = s => { let t = -1 / 0, e = 1 / 0; return w(s).forEach(a => (t = a > t ? a : t, e = a < e ? a : e, a)), [e, t] }, tt = s => { let t = (i, a) => { if (a[0] instanceof Array) for (let r = 0; r < a.length; r++)i[r] = [], t(i[r], a[r]); else for (let r = 0; r < a.length; r++)i[r] = a[r] }, e = w(s); if (e.data instanceof Array) { let i = []; return t(i, e.data), new p(i, e.shape) } else return new p(e.data, e.shape) }, ii = (s, t = []) => { s instanceof p && (s = s.shape); let e = t[0] == null ? -1 : t[0], i = t[1] == null ? 1 : t[1], a = t[2], r = 1; for (let l = 0; l < s.length; l++)r *= s[l]; let n = []; if (a == null) for (let l = 0; l < r; l++)n[l] = Math.random() * (i - e) + e; else for (let l = 0; l < r; l++)n[l] = Math.floor(Math.random() * (i - e) + e); return D(n, s) }, jt = s => { let t = w(s), e = []; return t.forEach(i => (e.push(i), i)), new p(e, [e.length]) }, te = (s, t) => jt(s).vectorToTensor(t), si = (s, t) => { let e = 1; for (let a = 0; a < t.length; a++)e *= t[a]; let i = w(s); if (e == i.data.length) { let a = i.data; for (let r = t.length - 1; r >= 0; r--) { let n = [], l = 0; for (let o = 0; o < a.length / t[r]; o++) { n[o] = []; for (let f = 0; f < t[r]; f++)n[o][f] = a[l], l++ } a = n } return a = a[0], new p(a, t) } else throw console.error("Based on the provided shape the tensor should have " + e + " values but has " + i.data.length) }, ee = (s, t) => { let e = w(s); if (t.length !== e.rank) throw console.error("Dimentions in reps " + t + " does not match with the number of dimentions from tensor " + e.shape); let i = []; for (let n = 0; n < e.rank; n++)i[n] = t[n] * e.shape[n]; let a = [], r = (n, l, o) => { if (n[0] instanceof Array) for (let f = 0; f < i[o]; f++)l[f] = [], r(n[f % e.shape[o]], l[f], o + 1); else for (let f = 0; f < i[i.length - 1]; f++)l[f] = n[f % e.shape[e.rank - 1]] }; return r(e.data, a, 0), At(a, i) }, B = (s, t) => { let e = w(s), i = e.shape.slice(); if (t.length < e.rank) throw console.error("Rank from shape " + t.length + " is minor than tensor rank " + e.rank); let a = e; if (t.length > e.rank) { let n = i.slice(); for (; n.length < t.length;)n.unshift(1); a = te(e, n) } let r = t.slice(); for (let n = 0; n < t.length; n++)if (a.shape[n] === t[n]) r[n] = 1; else if (a.shape[n] !== 1) throw console.error(i + " cannot be broadcast to " + t); return ee(a, r) }, ie = (s, t) => { let e = s.slice(), i = t.slice(); if (e.length > i.length) for (; i.length < e.length;)i.unshift(1); else for (; e.length < i.length;)e.unshift(1); let a = []; for (let r = 0; r < e.length; r++)a[r] = Math.max(e[r], i[r]); return a }, ai = s => { let t = [], e = s[0].shape; for (let i = 0; i < s.length; i++) { for (let a = 0; a < s[i].rank; a++)if (s[i].shape[a] !== e[a]) { console.error("Tensors must have the same shape"); return } t[i] = s[i].data } return e.unshift(s.length), new p(t, e) }, ri = s => { let t = w(s), e = t.shape.slice(); e.shift(); let i = []; for (let a = 0; a < t.data.length; a++)i[a] = new p(t.data[a], e); return i }; class p { constructor(t, e = [], i = e.length) { u(this, "data"); u(this, "shape"); u(this, "rank"); this.data = t, this.shape = e, this.rank = i } add(t) { if (typeof t == "number") return this.setData(this.forEach(a => a + t), this.shape); let e = w(t), i = this.shape; return this.shapesEqual(e.shape) || (i = this.broadcastArgs(e.shape), this.broadcastTo(i), e = B(e, i)), this.setData(this.forEachOfBoth(e.data, (a, r) => a + r), i) } sub(t) { if (typeof t == "number") return this.setData(this.forEach(a => a - t), this.shape); let e = w(t), i = this.shape; return this.shapesEqual(e.shape) || (i = this.broadcastArgs(e.shape), this.broadcastTo(i), e = B(e, i)), this.setData(this.forEachOfBoth(e.data, (a, r) => a - r), i) } mult(t) { if (typeof t == "number") return this.setData(this.forEach(a => a * t), this.shape); let e = w(t), i = this.shape; return this.shapesEqual(e.shape) || (i = this.broadcastArgs(e.shape), this.broadcastTo(i), e = B(e, i)), this.setData(this.forEachOfBoth(e.data, (a, r) => a * r), i) } div(t) { if (typeof t == "number") return this.setData(this.forEach(a => a / t), this.shape); let e = w(t), i = this.shape; return this.shapesEqual(e.shape) || (i = this.broadcastArgs(e.shape), this.broadcastTo(i), e = B(e, i)), this.setData(this.forEachOfBoth(e.data, (a, r) => a / r), i) } divNoNan(t) { if (typeof t == "number") return this.setData(this.forEach(a => t == 0 ? 0 : a / t), this.shape); let e = w(t), i = this.shape; return this.shapesEqual(e.shape) || (i = this.broadcastArgs(e.shape), this.broadcastTo(i), e = B(e, i)), this.setData(this.forEachOfBoth(e.data, (a, r) => r == 0 ? 0 : a / r), i) } floorDiv(t) { if (typeof t == "number") return this.setData(this.forEach(a => Math.floor(a / t)), this.shape); let e = w(t), i = this.shape; return this.shapesEqual(e.shape) || (i = this.broadcastArgs(e.shape), this.broadcastTo(i), e = B(e, i)), this.setData(this.forEachOfBoth(e.data, (a, r) => Math.floor(a / r)), i) } floorDivNoNan(t) { if (typeof t == "number") return this.setData(this.forEach(a => Math.floor(t == 0 ? 0 : a / t)), this.shape); let e = w(t), i = this.shape; return this.shapesEqual(e.shape) || (i = this.broadcastArgs(e.shape), this.broadcastTo(i), e = B(e, i)), this.setData(this.forEachOfBoth(e.data, (a, r) => Math.floor(r == 0 ? 0 : a / r)), i) } pow(t) { if (typeof t == "number") return this.setData(this.forEach(a => a ** t), this.shape); let e = w(t), i = this.shape; return this.shapesEqual(e.shape) || (i = this.broadcastArgs(e.shape), this.broadcastTo(i), e = B(e, i)), this.setData(this.forEachOfBoth(e.data, (a, r) => a ** r), i) } sqd(t) { if (typeof t == "number") return this.setData(this.forEach(a => (a - t) ** 2), this.shape); let e = w(t), i = this.shape; return this.shapesEqual(e.shape) || (i = this.broadcastArgs(e.shape), this.broadcastTo(i), e = B(e, i)), this.setData(this.forEachOfBoth(e.data, (a, r) => (a - r) ** 2), i) } square() { return this.forEach(t => t ** 2), this } sqrt() { return this.forEach(t => t ** .5), this } remap(t, e, i, a) { return this.forEach(r => (r - t) / (e - t) * (a - i) + i), this } map(t) { return this.forEach(e => t(e)), this } neg() { return this.forEach(t => -t), this } log() { return this.forEach(t => t == 0 ? -1e3 : Math.log(t)), this } constrain(t, e = 1) { let i, a; return t instanceof Array ? (i = t[0], a = t[1]) : (i = t, a = e), this.forEach(r => Math.max(Math.min(r, a), i)), this } exp() { return this.forEach(t => Math.exp(A(t, -50, 50))), this } dot(t) { let e = w(t); return this.rank == 2 ? e.rank == 2 ? this.dotMxM(e) : this.dotMxV(e) : e.rank == 2 ? this.dotVxM(e) : this.dotVxV(e) } dotMxM(t) { if (this.shape[1] !== t.shape[0]) throw console.error("Colums of A must match rows of B"); let e = []; for (let i = 0; i < this.shape[0]; i++) { e[i] = []; for (let a = 0; a < t.shape[1]; a++) { let r = 0; for (let n = 0; n < this.shape[1]; n++)r += this.data[i][n] * t.data[n][a]; e[i][a] = r } } return this.data = e, this.shape = [this.shape[0], t.shape[1]], this.rank = this.shape.length, this } dotMxV(t) { if (this.shape[1] !== t.shape[0]) throw console.error("Colums of A must match rows of B"); let e = []; for (let i = 0; i < this.shape[0]; i++) { let a = 0; for (let r = 0; r < this.shape[1]; r++)a += this.data[i][r] * t.data[r]; e[i] = a } return this.data = e, this.shape = [this.shape[0]], this.rank = this.shape.length, this } dotVxM(t) { if (t.shape[0] !== 1) throw console.error("Colums of A must match rows of B"); let e = []; for (let i = 0; i < this.shape[0]; i++) { e[i] = []; for (let a = 0; a < t.shape[1]; a++)e[i][a] = this.data[i] * t.data[0][a] } return this.data = e, this.shape = [this.shape[0], t.shape[1]], this.rank = this.shape.length, this } dotVxV(t) { if (this.shape[0] !== t.shape[0]) throw console.error("Colums of A must match rows of B"); let e = 0; for (let i = 0; i < this.shape[0]; i++)e += this.data[i] * t.data[i]; return this.data = e, this.shape = [], this.rank = 0, this } transpose() { if (this.rank == 2) { let e = []; for (let i = 0; i < this.shape[1]; i++) { e[i] = []; for (let a = 0; a < this.shape[0]; a++)e[i][a] = this.data[a][i] } return this.data = e, this.shape = [this.shape[1], this.shape[0]], this } let t = [[]]; for (let e = 0; e < this.shape[0]; e++)t[0][e] = this.data[e]; return this.data = t, this.shape = [1, this.shape[0]], this.rank = 2, this } mirrorHorizontally() { for (let t = 0; t < this.shape[0]; t++)for (let e = 0, i = this.shape[1] - 1; e < i; e++, i--) { let a = this.data[t][e]; this.data[t][e] = this.data[t][i], this.data[t][i] = a } return this } mirrorVertically() { for (let t = 0; t < this.shape[1]; t++)for (let e = 0, i = this.shape[0] - 1; e < i; e++, i--) { let a = this.data[e][t]; this.data[e][t] = this.data[i][t], this.data[i][t] = a } return this } rotate180() { for (let t = 0; t < this.shape[0]; t++)for (let e = 0, i = this.shape[1] - 1; e < i; e++, i--) { let a = this.data[t][e]; this.data[t][e] = this.data[t][i], this.data[t][i] = a } for (let t = 0; t < this.shape[1]; t++)for (let e = 0, i = this.shape[0] - 1; e < i; e++, i--) { let a = this.data[e][t]; this.data[e][t] = this.data[i][t], this.data[i][t] = a } return this } rotate90() { let t = [], e = 0, i = 0; for (let a = 0; a < this.shape[1]; a++) { t[i] = [], e = 0; for (let r = this.shape[0] - 1; r >= 0; r--)t[i][e] = this.data[r][a], e++; i++ } return this.data = t, this.shape = [this.shape[1], this.shape[0]], this } rotate270() { let t = [], e, i = 0; for (let a = this.shape[1] - 1; a >= 0; a--) { t[i] = [], e = 0; for (let r = 0; r < this.shape[0]; r++)t[i][e] = this.data[r][a], e++; i++ } return this.data = t, this.shape = [this.shape[1], this.shape[0]], this } shuffle() { let t = this.shape[0] - 1; for (; t > 0;) { let e = Math.floor(Math.random() * t + 1), i = this.data[t]; this.data[t] = this.data[e], this.data[e] = i, t -= 1 } return this } fill(t = 0) { return this.forEach(() => t), this } size() { let t = 1; for (let e = 0; e < this.rank; e++)t *= this.shape[e]; return t } rangeOfValues() { let t = -1 / 0, e = 1 / 0; return this.forEach(i => (t = i > t ? i : t, e = i < e ? i : e, i)), [e, t] } setData(t, e, i) { return this.data = t, this.shape = e || _(t), this.rank = i || this.shape.length, this } shapesEqual(t) { if (this.rank !== t.length) return !1; for (let e = 0; e < this.rank; e++)if (this.shape[e] !== t[e]) return !1; return !0 } inferShape() { let t = [], e = this.data; for (; e instanceof Array;)t.push(e.length), e = e[0]; return t } inferRank() { let t = 0, e = this.data; for (; e instanceof Array;)t += 1, e = e[0]; return t } copy() { let t = (e, i) => { if (i[0] instanceof Array) for (let a = 0; a < i.length; a++)e[a] = [], t(e[a], i[a]); else for (let a = 0; a < this.shape[this.rank - 1]; a++)e[a] = i[a] }; if (this.data instanceof Array) { let e = []; return t(e, this.data), new p(e, this.shape) } else return new p(this.data, this.shape) } randomize(t = []) { let e = t[0] == null ? -1 : t[0], i = t[1] == null ? 1 : t[1]; return t[2] == null ? this.forEach(() => Math.random() * (i - e) + e) : this.forEach(() => Math.floor(Math.random() * (i + 1 - e) + e)), this } mean() { let t = 0, e = 0; return this.forEach(i => (e++, t += i, i)), t / e } sumExp() { let t = 0; return this.forEach(e => (t += Math.exp(A(e, -50, 50)), e)), t } max() { let t = -1 / 0; return this.forEach(e => (t = e > t ? e : t, e)), t } sum() { let t = 0; return this.forEach(e => (t += e, e)), t } flatten() { let t = []; return this.forEach(e => (t.push(e), e)), this.setData(t) } reshape(t) { return this.flatten().vectorToTensor(t) } vectorToTensor(t) { let e = 1; for (let a = 0; a < t.length; a++)e *= t[a]; if (this.data.length !== e) throw console.error("Based on the provided shape the tensor should have " + e + " values but has " + this.data.length); let i = this.data.slice(); for (let a = t.length - 1; a >= 0; a--) { let r = [], n = 0; for (let l = 0; l < i.length / t[a]; l++) { r[l] = []; for (let o = 0; o < t[a]; o++)r[l][o] = i[n], n++ } i = r } return this.setData(i[0], t) } tile(t) { if (t.length !== this.rank) throw console.error("Dimentions in reps: " + t + ", does not match with the number of dimentions from tensor: " + this.shape); let e = []; for (let r = 0; r < this.rank; r++)e[r] = t[r] * this.shape[r]; let i = [], a = (r, n, l) => { if (r[0] instanceof Array) for (let o = 0; o < e[l]; o++)n[o] = [], a(r[o % this.shape[l]], n[o], l + 1); else for (let o = 0; o < e[e.length - 1]; o++)n[o] = r[o % this.shape[this.rank - 1]] }; return a(this.data, i, 0), this.setData(i, e) } broadcastTo(t) { let e = this.shape.slice(); if (t.length < this.rank) throw console.error("Rank from shape " + t.length + " is minor than tensor rank " + this.rank); if (t.length > this.rank) { let a = this.shape.slice(); for (; a.length < t.length;)a.unshift(1); this.reshape(a) } let i = t.slice(); for (let a = 0; a < t.length; a++)if (this.shape[a] === t[a]) i[a] = 1; else if (this.shape[a] !== 1) throw console.error(e + " cannot be broadcast to " + t); return this.tile(i) } broadcastArgs(t) { let e = this.shape.slice(), i = t.slice(); if (e.length > i.length) for (; i.length < e.length;)i.unshift(1); else for (; e.length < i.length;)e.unshift(1); let a = []; for (let r = 0; r < e.length; r++)a[r] = Math.max(e[r], i[r]); return a } forEach(t) { let e = i => { if (i[0] instanceof Array) for (let a = 0; a < i.length; a++)e(i[a]); else for (let a = 0; a < i.length; a++)i[a] = t(i[a]) }; return this.data instanceof Array ? e(this.data) : this.data = t(this.data), this.data } forEachOfBoth(t, e) { let i = (a, r) => { if (a[0] instanceof Array) for (let n = 0; n < a.length; n++)i(a[n], r[n]); else for (let n = 0; n < a.length; n++)a[n] = e(a[n], r[n]) }; return this.data instanceof Array && t instanceof Array ? (i(this.data, t), this.data) : (typeof this.data == "number" && typeof t == "number" && (this.data = e(this.data, t)), this.data) } accesLastArray(t) { let e = i => { if (i[0] instanceof Array) for (let a = 0; a < i.length; a++)e(i[a]); else t(i) }; return e(this.data), this.data } accesLastArrays(t, e) { let i = (a, r) => { if (a[0] instanceof Array) for (let n = 0; n < a.length; n++)i(a[n], r[n]); else e(a, r) }; return i(this.data, t), this.data } static serialize(t) { return JSON.stringify(t) } static deserialize(t) { return typeof t == "string" && (t = JSON.parse(t)), new p(t.data, t.shape) } } const se = (s, t) => { let e = i => { if (i[0] instanceof Array) for (let a = 0; a < i.length; a++)e(i[a]); else for (let a = 0; a < i.length; a++)i[a] = t(i[a]) }; return s instanceof Array ? (e(s), s) : t(s) }, C = (s, t) => { let e = (i, a) => { if (i[0] instanceof Array) for (let r = 0; r < i.length; r++)a[r] = [], e(i[r], a[r]); else for (let r = 0; r < i.length; r++)a[r] = t(i[r]) }; if (s instanceof Array) { let i = []; return e(s, i), i } else return t(s) }, ni = (s, t, e) => { let i = (a, r) => { if (a[0] instanceof Array) for (let n = 0; n < a.length; n++)i(a[n], r[n]); else for (let n = 0; n < a.length; n++)a[n] = e(a[n], r[n]) }; return s instanceof Array ? t instanceof Array ? (i(s, t), s) : se(s, a => e(a, t)) : t instanceof Array ? Et(C(t, a => e(a, s))) : e(s, t) }, ae = (s, t, e) => { let i = (a, r, n) => { if (a[0] instanceof Array) for (let l = 0; l < a.length; l++)n[l] = [], i(a[l], r[l], n[l]); else for (let l = 0; l < a.length; l++)n[l] = e(a[l], r[l]) }; if (s instanceof Array) { if (t instanceof Array) { let a = []; return i(s, t, a), a } return C(s, a => e(a, t)) } else if (t instanceof Array) return C(t, a => e(a, s)); return e(s, t) }, hi = (s, t) => { let e = i => { if (i[0] instanceof Array) for (let a = 0; a < i.length; a++)e(i[a]); else t(i) }; return e(s), s }, li = (s, t) => { let e = [], i = (a, r) => { if (a[0] instanceof Array) for (let n = 0; n < a.length; n++)r[n] = [], i(a[n], r[n]); else t(a, r) }; return i(s, e), e }, oi = (s, t, e) => { let i = (a, r) => { if (a[0] instanceof Array) for (let n = 0; n < a.length; n++)i(a[n], r[n]); else e(a, r) }; i(s, t) }, ui = (s, t, e) => { let i = [], a = (r, n, l) => { if (r[0] instanceof Array) for (let o = 0; o < r.length; o++)l[o] = [], a(r[o], n[o], l[o]); else e(r, n, l) }; return a(s, t, i), i }, L = s => (t, e) => { if (typeof t != "number") { let i = w(t); if (typeof e == "number") return new p(C(i.data, n => s(n, e)), i.shape); let a = w(e), r = i.shape; return gt(i.shape, a.shape) || (r = ie(i.shape, a.shape), i = B(i, r), a = B(a, r)), new p(ae(i.data, a.data, (n, l) => s(n, l)), r) } if (typeof e != "number") { let i = e instanceof p ? e.data : e; return At(C(i, a => s(t, a))) } return new p(s(t, e)) }, G = L((s, t) => s + t), F = L((s, t) => s - t), k = L((s, t) => s * t), wt = L((s, t) => s / t), E = L((s, t) => t == 0 ? 0 : s / t), fi = L((s, t) => Math.floor(s / t)), pi = L((s, t) => Math.floor(t == 0 ? 0 : s / t)), ci = L((s, t) => s ** t), re = L((s, t) => (s - t) * (s - t)), di = L((s, t) => Math.atan2(s, t)), mi = s => { let t = 0, e = 0; return w(s).forEach(a => (e++, t += a, a)), t / e }, et = s => { let t = w(s), e = 0; return t.forEach(i => (e += Math.exp(A(i, -50, 50)), i)), e }, St = s => { let t = w(s), e = -1 / 0; return t.forEach(i => (e = i > e ? i : e, i)), e }, Ct = s => { let t = w(s), e = 1 / 0; return t.forEach(i => (e = i < e ? i : e, i)), e }, gi = s => { let t = w(s), e = 0; return t.forEach(i => (e += i, i)), e }, b = s => t => { let e = w(t), i = C(e.data, a => s(a)); return new p(i, e.shape) }, wi = b(s => -s), Si = b(s => Math.abs(s)), zi = b(s => Math.acos(s)), Mi = b(s => Math.acosh(s)), ki = b(s => Math.asin(s)), vi = b(s => Math.asinh(s)), yi = b(s => Math.atan(s)), bi = b(s => Math.cbrt(s)), Ii = b(s => Math.ceil(s)), Ai = b(s => Math.cos(s)), Ei = b(s => Math.cosh(s)), it = b(s => Math.exp(s)), Ti = b(s => Math.expm1(s)), Ci = b(s => Math.floor(s)), st = b(s => Math.log(s)), Fi = b(s => Math.log10(s)), Ni = b(s => Math.log2(s)), Oi = b(s => Math.round(s)), _i = b(s => Math.sign(s)), Bi = b(s => Math.sin(s)), Ri = b(s => Math.sinh(s)), Di = b(s => Math.sqrt(s)), U = b(s => s * s), Li = b(s => Math.tan(s)), qi = b(s => Math.tanh(s)), Gi = b(s => Math.trunc(s)), Pi = b(s => 1 / (1 + Math.exp(-s))), Vi = b(s => Math.max(0, s)), Ui = b(s => Math.max(.05 * s, s)), Wi = b(s => s > 0 ? s : .05 * (Math.exp(s) - 1)), xi = b(s => Math.log(1 + Math.exp(s))), Ji = (s, t = 0) => { let e = w(s), i = C(e.data, a => a > 0 ? 1 : t * a); return new p(i, e.shape) }, Hi = s => { let t = w(s), e = F(t, t.max()); return wt(it(e), et(e)) }, Xi = (s, t, e, i, a) => { let r = w(s), n = C(r.data, l => (l - t) / (e - t) * (a - i) + i); return new p(n, r.shape) }, Zi = (s, t = 0, e = 1) => { let i = w(s), a = C(i.data, r => (r - Ct(i.data)) / (St(i.data) - Ct(i.data)) * (e - t) + t); return new p(a, i.shape) }, N = (s, t) => { let e = w(s), i = C(e.data, a => t(a)); return new p(i, e.shape) }, Ki = (s, t, e) => { let i = w(s), a = C(i.data, r => Math.max(Math.min(r, e), t)); return new p(a, i.shape) }, ne = s => { let t = w(s); return U(F(t, t.mean())).mean() }, Qi = s => { let t = w(s); return Math.sqrt(U(F(t, t.mean())).mean()) }, Yi = (s, t = -50, e = 50) => { let i = w(s), a = C(i.data, r => Math.exp(A(r, t, e))); return new p(a, i.shape) }, $i = (s, t = 1e-100, e = 1 / 0) => { let i = w(s), a = C(i.data, r => Math.exp(A(r, t, e))); return new p(a, i.shape) }, he = (s, t) => { if (s.shape[1] !== t.shape[0]) throw console.error("Colums of A must match rows of B"); let e = []; for (let i = 0; i < s.shape[0]; i++) { e[i] = []; for (let a = 0; a < t.shape[1]; a++) { let r = 0; for (let n = 0; n < s.shape[1]; n++)r += s.data[i][n] * t.data[n][a]; e[i][a] = r } } return new p(e, [s.shape[0], t.shape[1]]) }, le = (s, t) => { if (s.shape[1] !== t.shape[0]) throw console.error("Colums of A must match rows of B"); let e = []; for (let i = 0; i < s.shape[0]; i++) { let a = 0; for (let r = 0; r < s.shape[1]; r++)a += s.data[i][r] * t.data[r]; e[i] = a } return new p(e, [s.shape[0]]) }, oe = (s, t) => { if (t.shape[0] !== 1) throw console.error("Colums of A must match rows of B"); let e = []; for (let i = 0; i < s.shape[0]; i++) { e[i] = []; for (let a = 0; a < t.shape[1]; a++)e[i][a] = s.data[i] * t.data[0][a] } return new p(e, [s.shape[0], t.shape[1]]) }, ue = (s, t) => { if (s.shape[0] !== t.shape[0]) throw console.error("Colums of A must match rows of B"); let e = 0; for (let i = 0; i < s.shape[0]; i++)e += s.data[i] * t.data[i]; return new p(e, []) }, X = (s, t) => s.rank == 2 ? t.rank == 2 ? he(s, t) : le(s, t) : t.rank == 2 ? oe(s, t) : ue(s, t), Ft = s => { let t = w(s); if (t.rank == 2) { let e = []; for (let i = 0; i < t.shape[1]; i++) { e[i] = []; for (let a = 0; a < t.shape[0]; a++)e[i][a] = t.data[a][i] } return new p(e, [t.shape[1], t.shape[0]]) } else { let e = [[]]; for (let i = 0; i < t.shape[0]; i++)e[0][i] = t.data[i]; return new p(e, [1, t.shape[0]]) } }, ji = s => { let t = w(s), e = []; for (let i = 0; i < t.shape[0]; i++) { e[i] = []; for (let a = 0, r = t.shape[1] - 1; a < r; a++, r--)e[i][a] = t.data[i][r], e[i][r] = t.data[i][a] } return new p(e, t.shape) }, ts = s => { let t = w(s), e = []; for (let i = 0; i < t.shape[1]; i++)e[i] = []; for (let i = 0; i < t.shape[1]; i++)for (let a = 0, r = t.shape[0] - 1; a < r; a++, r--)e[a][i] = t.data[r][i], e[r][i] = t.data[a][i]; return new p(e, t.shape) }, at = s => { let t = w(s), e = []; for (let i = 0; i < t.shape[0]; i++) { e[i] = t.data[i].slice(); for (let a = 0, r = t.shape[1] - 1; a < r; a++, r--)e[i][a] = t.data[i][r], e[i][r] = t.data[i][a] } for (let i = 0; i < t.shape[1]; i++)for (let a = 0, r = t.shape[0] - 1; a < r; a++, r--)e[a][i] = t.data[r][i], e[r][i] = t.data[a][i]; return new p(e, t.shape) }, es = s => { let t = w(s), e = [], i = 0, a = 0; for (let r = 0; r < t.shape[1]; r++) { e[a] = [], i = 0; for (let n = t.shape[0] - 1; n >= 0; n--)e[a][i] = t.data[n][r], i++; a++ } return new p(e, [t.shape[1], t.shape[0]]) }, is = s => { let t = w(s), e = [], i, a = 0; for (let r = t.shape[1] - 1; r >= 0; r--) { e[a] = [], i = 0; for (let n = 0; n < t.shape[0]; n++)e[a][i] = t.data[n][r], i++; a++ } return new p(e, [t.shape[1], t.shape[0]]) }, R = (s, t) => { let e = w(s); if (t[0] == 0 && t[1] == 0) return e; let i = t[0], a = t[1], r = Math.floor(t[0] / 2), n = t[0] - r, l = Math.floor(t[1] / 2), o = t[1] - l, f = []; for (let d = 0; d < e.shape[1]; d++) { f[d] = e.data[d].slice(); for (let m = 0; m < l; m++)f[d].unshift(0); for (let m = 0; m < o; m++)f[d].push(0) } for (let d = 0; d < r; d++)f.unshift(new Array(f[0].length).fill(0)); for (let d = 0; d < n; d++)f.push(new Array(f[0].length).fill(0)); return new p(f, [e.shape[0] + i, e.shape[1] + a]) }, Nt = (s, t, e, i, a) => { let r = [(s[0] + e[0] - a[0] * (t[0] - 1) - 1) / i[0] + 1, (s[1] + e[1] - a[1] * (t[1] - 1) - 1) / i[1] + 1]; return r = [Math.floor(r[0]), Math.floor(r[1])], r }, Ot = (s, t, e, i, a) => { let r = [s[0], (s[1] + e[0] - a[0] * (t[1] - 1) - 1) / i[0] + 1, (s[2] + e[1] - a[1] * (t[2] - 1) - 1) / i[1] + 1]; return r = [Math.floor(r[0]), Math.floor(r[1]), Math.floor(r[2])], r }, _t = (s, t, e, i, a) => { let r = [s[0], (s[1] + e[0] - a[0] * (t[0] - 1) - 1) / i[0] + 1, (s[2] + e[1] - a[1] * (t[1] - 1) - 1) / i[1] + 1]; return r = [Math.floor(r[0]), Math.floor(r[1]), Math.floor(r[2])], r }, Z = (s, t, e, i, a) => { let r = [t[0], (s[1] + e[0] - a[0] * (t[2] - 1) - 1) / i[0] + 1, (s[2] + e[1] - a[1] * (t[3] - 1) - 1) / i[1] + 1]; return r = [Math.floor(r[0]), Math.floor(r[1]), Math.floor(r[2])], r }, fe = (s, t, e, i) => [Math.floor((s[0] + t[0] - e[0]) / i[0] + 1), Math.floor((s[1] + t[1] - e[1]) / i[1] + 1)], zt = (s, t, e, i) => [s[0], Math.floor((s[1] + t[0] - e[0]) / i[0] + 1), Math.floor((s[2] + t[1] - e[1]) / i[1] + 1)], q = (s, t, e, i = [1, 1], a = [1, 1]) => { if (e == "valid") return [0, 0]; let r, n, l = [s[s.length - 2], s[s.length - 1]], o = [t[t.length - 2], t[t.length - 1]]; return e == "same" ? (r = Math.floor(a[0] * (o[0] - 1) + (l[0] - 1) * (i[0] - 1)), n = Math.floor(a[1] * (o[1] - 1) + (l[1] - 1) * (i[1] - 1)), [r, n]) : e == "full" ? (r = (o[0] - 1) * 2, n = (o[1] - 1) * 2, [r, n]) : [0, 0] }, rt = (s, t, e, i) => { if (t) { let a = [Math.floor((s[s.length - 2] - e[0]) / i[0]) + 1, Math.floor((s[s.length - 1] - e[1]) / i[1]) + 1], r = [e[0] + (a[0] - 1) * i[0], e[1] + (a[1] - 1) * i[1]], n = [s[s.length - 2] - r[0], s[s.length - 1] - r[1]]; return [n[0] > 0 ? e[0] - n[0] : 0, n[1] > 0 ? e[1] - n[1] : 0] } else return [0, 0] }, pe = (s, t, e = "valid", i = [1, 1], a = [1, 1]) => { let r = w(s), n = w(t), l = e instanceof Array ? e : q(r.shape, n.shape, e, i, a); if (r.rank == 2) { let o = Nt(r.shape, n.shape, l, i, a), f = R(r, l), d = []; for (let m = 0; m < o[0]; m++) { d[m] = []; for (let c = 0; c < o[1]; c++) { let g = 0; for (let S = 0; S < n.shape[0]; S++)for (let z = 0; z < n.shape[1]; z++) { let M = S * a[0] + m * i[0], v = z * a[1] + c * i[1]; g += f.data[M][v] * n.data[S][z] } d[m][c] = g } } return new p(d, o) } else { let o = Ot(r.shape, n.shape, l, i, a), f = []; for (let m = 0; m < r.shape[0]; m++)f[m] = R(r.data[m], l).data; f = new p(f, _(f)); let d = y(o); for (let m = 0; m < f.shape[0]; m++)for (let c = 0; c < o[1]; c++)for (let g = 0; g < o[2]; g++) { let S = 0; for (let z = 0; z < n.shape[1]; z++)for (let M = 0; M < n.shape[2]; M++) { let v = z * a[0] + c * i[0], I = M * a[1] + g * i[1]; S += f.data[m][v][I] * n.data[m][z][M] } d.data[m][c][g] += S } return d } }, ss = (s, t, e = "valid", i = [1, 1], a = [1, 1]) => { let r = w(s), n = w(t), l = e instanceof Array ? e : q(r.shape, n.shape, e, i, a); n.shape.slice().shift(); let f = _t(r.shape, n.shape, l, i, a), d = []; for (let c = 0; c < r.shape[0]; c++)d[c] = R(r.data[c], l).data; d = new p(d, _(d)); let m = y(f); for (let c = 0; c < d.shape[0]; c++)for (let g = 0; g < f[1]; g++)for (let S = 0; S < f[2]; S++) { let z = 0; for (let M = 0; M < n.shape[2]; M++)for (let v = 0; v < n.shape[3]; v++) { let I = M * a[0] + g * i[0], O = v * a[1] + S * i[1]; z += d.data[c][I][O] * n.data[M][v] } m.data[c][g][S] += z } return m }, as = (s, t, e = "valid", i = [1, 1], a = [1, 1]) => { let r = w(s), n = w(t), l = e instanceof Array ? e : q(r.shape, n.shape, e, i, a), o = []; for (let m = 0; m < r.shape[0]; m++)o[m] = R(r.data[m], l).data; o = new p(o, _(o)); let f = Z(r.shape, n.shape, l, i, a), d = y(f); for (let m = 0; m < n.shape[0]; m++)for (let c = 0; c < r.shape[0]; c++)for (let g = 0; g < f[1]; g++)for (let S = 0; S < f[2]; S++) { let z = 0; for (let M = 0; M < n.shape[2]; M++)for (let v = 0; v < n.shape[3]; v++) { let I = M * a[0] + g * i[0], O = v * a[1] + S * i[1]; z += o.data[c][I][O] * n.data[m][c][M][v] } d.data[m][g][S] += z } return d }, Bt = (s, t, e, i = "valid", a = [1, 1], r = [1, 1]) => { let n = w(s), l = w(t), o = w(e), f = i instanceof Array ? i : q(n.shape, l.shape, i, a, r), d = []; for (let g = 0; g < n.shape[0]; g++)d[g] = R(n.data[g], f).data; d = new p(d, _(d)); let m = Z(n.shape, l.shape, f, a, r), c = y(m); for (let g = 0; g < l.shape[0]; g++)for (let S = 0; S < n.shape[0]; S++)for (let z = 0; z < m[1]; z++)for (let M = 0; M < m[2]; M++) { let v = 0; for (let I = 0; I < l.shape[2]; I++)for (let O = 0; O < l.shape[3]; O++) { let dt = I * r[0] + z * a[0], zs = O * r[1] + M * a[1]; v += d.data[S][dt][zs] * l.data[g][S][I][O] } c.data[g][z][M] += v + o.data[g][z][M] / m[0] } return c }, ce = (s, t, e = "valid", i = [1, 1], a = [1, 1]) => { let r = w(s), n = w(t), l = e instanceof Array ? e : q(r.shape, n.shape, e, i, a); if (r.rank == 2) { let o = at(n), f = Nt(r.shape, n.shape, l, i, a), d = R(r, l), m = []; for (let c = 0; c < f[0]; c++) { m[c] = []; for (let g = 0; g < f[1]; g++) { let S = 0; for (let z = 0; z < o.shape[0]; z++)for (let M = 0; M < o.shape[1]; M++) { let v = z * a[0] + c * i[0], I = M * a[1] + g * i[1]; S += d.data[v][I] * o.data[z][M] } m[c][g] = S } } return new p(m, f) } else { let o = Ot(r.shape, n.shape, l, i, a), f = [], d = []; for (let c = 0; c < r.shape[0]; c++)f[c] = R(r.data[c], l).data, d[c] = at(n.data[c]).data; f = new p(f, _(f)), d = new p(d, n.shape); let m = y(o); for (let c = 0; c < f.shape[0]; c++)for (let g = 0; g < o[1]; g++)for (let S = 0; S < o[2]; S++) { let z = 0; for (let M = 0; M < d.shape[1]; M++)for (let v = 0; v < d.shape[2]; v++) { let I = M * a[0] + g * i[0], O = v * a[1] + S * i[1]; z += f.data[c][I][O] * d.data[c][M][v] } m.data[c][g][S] += z } return m } }, rs = (s, t, e = "valid", i = [1, 1], a = [1, 1]) => { let r = w(s), n = w(t), l = e instanceof Array ? e : q(r.shape, n.shape, e, i, a); n.shape.slice().shift(); let f = _t(r.shape, n.shape, l, i, a), d = []; for (let g = 0; g < r.shape[0]; g++)d[g] = R(r.data[g], l).data; d = new p(d, _(d)); let m = at(n), c = y(f); for (let g = 0; g < d.shape[0]; g++)for (let S = 0; S < f[1]; S++)for (let z = 0; z < f[2]; z++) { let M = 0; for (let v = 0; v < m.shape[2]; v++)for (let I = 0; I < m.shape[3]; I++) { let O = v * a[0] + S * i[0], dt = I * a[1] + z * i[1]; M += d.data[g][O][dt] * m.data[v][I] } c.data[g][S][z] += M } return c }, ns = (s, t, e = "valid", i = [1, 1], a = [1, 1]) => { let r = w(s), n = w(t), l = e instanceof Array ? e : q(r.shape, n.shape, e, i, a), o = []; for (let c = 0; c < r.shape[0]; c++)o[c] = R(r.data, l).data; o = new p(o, _(o)); let f = []; for (let c = 0; c < n.shape[0]; c++) { f[c] = []; for (let g = 0; g < n.shape[1]; g++)f[c][g] = at(n.data[c][g]).data } f = new p(f, n.shape); let d = Z(r.shape, f.shape, l, i, a), m = y(d); for (let c = 0; c < f.shape[0]; c++)for (let g = 0; g < r.shape[0]; g++)for (let S = 0; S < d[1]; S++)for (let z = 0; z < d[2]; z++) { let M = 0; for (let v = 0; v < f.shape[2]; v++)for (let I = 0; I < f.shape[3]; I++) { let O = v * a[0] + S * i[0], dt = I * a[1] + z * i[1]; M += o.data[g][O][dt] * f.data[c][g][v][I] } m.data[c][S][z] += M } return m }, hs = (s, t, e = [2, 2], i = e, a) => { a = []; let r = w(s), n = t instanceof Array ? t.slice() : rt(r.shape, t, e, i), l = R(r.data, n), o = fe(r.shape, n, e, i), f = y(o); for (let d = 0; d < o[0]; d++)for (let m = 0; m < o[1]; m++) { let c = -1 / 0, g = []; for (let S = 0; S < e[0]; S++)for (let z = 0; z < e[1]; z++) { let M = S + d * i[0], v = z + m * i[1]; l.data[M][v] > c && (c = l.data[M][v], g = [M, v, d, m]) } a.push(g), f.data[d][m] = c } return f }, de = (s, t, e = [2, 2], i = e, a = []) => { a = []; let r = w(s), n = t instanceof Array ? t.slice() : rt(r.shape, t, e, i), l = []; for (let d = 0; d < r.shape[0]; d++)l[d] = R(r.data[d], n).data; l = Et(l); let o = zt(r.shape, n, e, i), f = y(o); for (let d = 0; d < l.shape[0]; d++)for (let m = 0; m < o[1]; m++)for (let c = 0; c < o[2]; c++) { let g = -1 / 0, S = []; for (let z = 0; z < e[0]; z++)for (let M = 0; M < e[1]; M++) { let v = z + m * i[0], I = M + c * i[1]; l.data[d][v][I] > g && (g = l.data[d][v][I], S = [d, v, I, m, c]) } a.push(S), f.data[d][m][c] = g } return f }, Rt = { fn: s => s, fnPrime: s => Yt(s.shape), updateError: s => s, name: "linear" }, nt = { fn: s => N(s, t => 1 / (1 + Math.exp(-t))), fnPrime: s => N(s, t => t * (1 - t)), updateError: (s, t) => k(s, t), name: "sigmoid" }, Dt = { fn: s => N(s, t => Math.max(0, t)), fnPrime: s => N(s, t => t > 0 ? 1 : 0), updateError: (s, t) => k(s, t), name: "relu" }, me = { fn: s => N(s, t => Math.max(.05 * t, t)), fnPrime: s => N(s, t => t > 0 ? 1 : .05), updateError: (s, t) => k(s, t), name: "leakyrelu" }, ge = { fn: s => N(s, t => t > 0 ? t : .05 * (Math.exp(t) - 1)), fnPrime: s => N(s, t => t > 0 ? 1 : .05 + t), updateError: (s, t) => k(s, t), name: "elu" }, we = { fn: s => N(s, t => Math.log(1 + Math.exp(t))), fnPrime: s => N(s, t => 1 / (1 + Math.exp(-t))), updateError: (s, t) => k(s, t), name: "softplus" }, Lt = { fn: s => N(s, t => t > 0 ? 1 : 0), fnPrime: s => N(s, () => 0), updateError: (s, t) => k(s, t), name: "binaryStep" }, qt = { fn: s => N(s, t => Math.tanh(t)), fnPrime: s => N(s, t => 1 - t ** 2), updateError: (s, t) => k(s, t), name: "tanh" }, Gt = { fn: s => { let t = F(s, s.max()); return wt(it(t), et(t)) }, fnPrime: s => { let t = []; for (let e = 0; e < s.shape[0]; e++) { t[e] = []; for (let i = 0; i < s.shape[0]; i++)e == i ? t[e][i] = s.data[e] * (1 - s.data[e]) : t[e][i] = -s.data[e] * s.data[i] } return new p(t, [s.shape[0], s.shape[0]]) }, updateError: (s, t) => X(t, s), name: "softmax" }, Mt = s => { switch (s) { case "sigmoid": return nt; case "relu": return Dt; case "leakyrelu": return me; case "elu": return ge; case "binaryStep": return Lt; case "tanh": return qt; case "softplus": return we; case "softmax": return Gt; case "linear": return Rt; default: return nt } }; var ls = Object.freeze({ __proto__: null, [Symbol.toStringTag]: "Module", linear: Rt, sigmoid: nt, relu: Dt, leakyrelu: me, elu: ge, softplus: we, binayStep: Lt, tanh: qt, softmax: Gt, handler: Mt }); const W = s => { s.map(i => Math.floor(i)); let t = 1, e = 1; if (s.length == 2) t = s[1], e = s[0]; else if (s.length == 4) { let i = s[2] * s[3]; t = i * s[1], e = i * s[0] } return [t, e] }; class T { constructor() { u(this, "name"); u(this, "args"); this.name = "", this.args } apply(t) { return new p([], t) } serialize() { return JSON.stringify(this) } } class Se extends T { constructor(t = {}) { super(); this.name = "constant", this.args = t } apply(t) { let e = this.args.value || 0; return mt(t, e) } } const Pt = (s = {}) => new Se(s); class ze extends T { constructor(t = {}) { super(); this.name = "ones", this.args = t } apply(t) { return mt(t, 1) } } const kt = (s = {}) => new ze(s); class Me extends T { constructor(t = {}) { super(); this.name = "zeros", this.args = t } apply(t) { return mt(t, 0) } } const x = (s = {}) => new Me(s); class ke extends T { constructor(t = {}) { super(); this.name = "randomUniform", this.args = t } apply(t) { let e = W(t)[0] || 1; e = 1 / Math.sqrt(e); let i = this.args.min || -e, a = this.args.max || e; return $(t, i, a) } } const K = (s = {}) => new ke(s); class ve extends T { constructor(t = {}) { super(); this.name = "randomNormal", this.args = t } apply(t) { let e = this.args.mean || 0, i = this.args.stddev || 1; return j(t, e, i) } } const Vt = (s = {}) => new ve(s); class ye extends T { constructor(t = {}) { super(); this.name = "xavierUniform", this.args = t } apply(t) { let e = W(t), i = e[0] || 1, a = e[1] || 1, r = Math.sqrt(6) / Math.sqrt(i + a); return $(t, -r, r) } } const Ut = (s = {}) => new ye(s); class be extends T { constructor(t = {}) { super(); this.name = "xavierNormal", this.args = t } apply(t) { let e = W(t), i = e[0] || 1, a = e[1] || 1, r = Math.sqrt(2 / (i + a)); return j(t, 0, r) } } const ht = (s = {}) => new be(s); class Ie extends T { constructor(t = {}) { super(); this.name = "heUniform", this.args = t } apply(t) { let i = W(t)[0] || 1, a = Math.sqrt(6 / i); return $(t, -a, a) } } const Wt = (s = {}) => new Ie(s); class Ae extends T { constructor(t = {}) { super(); this.name = "heNormal", this.args = t } apply(t) { let i = W(t)[0] || 1, a = Math.sqrt(2 / i); return j(t, 0, a) } } const xt = (s = {}) => new Ae(s); class Ee extends T { constructor(t = {}) { super(); this.name = "varianceScaling", this.args = t } apply(t) { let e = W(t), i = e[0] || 1, a = e[1] || 1, r = this.args.scale || 1, n = i; if (this.args.mode == "fan_out" ? n = a : this.args.mode == "avg" && (n = (i + a) / 2), this.args.distribution == "uniform") { let l = Math.sqrt(3 * r / n); return $(t, -l, l) } else { let l = Math.sqrt(r / n); return j(t, 0, l) } } } const Jt = (s = {}) => new Ee(s), J = s => { switch (s) { case "constant": return Pt; case "ones": return kt; case "zeros": return x; case "randomUniform": return K; case "randomNormal": return Vt; case "xavierUniform": return Ut; case "xavierNormal": return ht; case "heUniform": return Wt; case "heNormal": return xt; case "varianceScaling": return Jt; default: return K } }, Ht = s => { switch (s.name) { case "constant": return Pt(s.args); case "ones": return kt(s.args); case "zeros": return x(s.args); case "randomUniform": return K(s.args); case "randomNormal": return Vt(s.args); case "xavierUniform": return Ut(s.args); case "xavierNormal": return ht(s.args); case "heUniform": return Wt(s.args); case "heNormal": return xt(s.args); case "varianceScaling": return Jt(s.args); default: return K() } }; var os = Object.freeze({ __proto__: null, [Symbol.toStringTag]: "Module", calculateFans: W, Initializer: T, Constant: Se, constant: Pt, Ones: ze, ones: kt, Zeros: Me, zeros: x, RandomUniform: ke, randomUniform: K, RandomNormal: ve, randomNormal: Vt, XavierUniform: ye, xavierUniform: Ut, XavierNormal: be, xavierNormal: ht, HeUniform: Ie, heUniform: Wt, HeNormal: Ae, heNormal: xt, VarianceScaling: Ee, varianceScaling: Jt, handler: J, fromObject: Ht }); class Q { constructor() { u(this, "input"); u(this, "inputBatch"); u(this, "type"); u(this, "isTrainable"); u(this, "name"); u(this, "output"); u(this, "outputBatch"); this.input = [new p([])], this.inputBatch = [new p([])], this.output = [new p([])], this.outputBatch = [new p([])], this.type = "", this.name = "", this.isTrainable = !1 } forward(t) { return t } backward(t) { return t } serialize() { return JSON.stringify(this) } } class vt extends Q { constructor() { super(); u(this, "weights"); u(this, "bias"); u(this, "weightsGradient"); u(this, "biasGradient"); u(this, "biasConstrain"); u(this, "weightsConstrain"); u(this, "optimizerWeights"); u(this, "optimizerBias"); u(this, "kernelInitializer"); u(this, "biasInitializer"); u(this, "parameters"); u(this, "activation"); u(this, "activationFunction"); this.name = this.type, this.activation = void 0, this.activationFunction = Rt, this.weights = new p([]), this.bias = new p([]), this.weightsConstrain = [-1e7, 1e7], this.biasConstrain = [-1e7, 1e7], this.weightsGradient = new p([]), this.biasGradient = new p([]), this.optimizerWeights = [this.weightsGradient], this.optimizerBias = [this.weightsGradient], this.kernelInitializer = K(), this.biasInitializer = x(), this.parameters = 0 } reshapeOptimizerParameters() { this.weightsGradient = y(this.weights.shape), this.biasGradient = y(this.bias.shape), this.optimizerWeights = [this.weightsGradient, y(this.weights.shape), y(this.weights.shape)], this.optimizerBias = [this.biasGradient, y(this.bias.shape), y(this.bias.shape)] } update(t, e = 1, i = 0) { this.weightsGradient.divNoNan(e), this.biasGradient.divNoNan(e), t.apply(this.weights, this.optimizerWeights, i), t.apply(this.bias, this.optimizerBias, i), this.weights.constrain(this.weightsConstrain), this.bias.constrain(this.biasConstrain), this.weightsGradient.mult(0), this.biasGradient.mult(0) } setParameters(t) { this.setWeights(Y(t.weights)), this.setBias(Y(t.bias)), this.kernelInitializer = Ht(t.kernelInitializer), this.biasInitializer = Ht(t.biasInitializer); for (let e = 1; e < t.optimizerWeights.length; e++)this.optimizerWeights[e] = tt(Y(t.optimizerWeights[e])), this.optimizerBias[e] = tt(Y(t.optimizerBias[e])) } setWeights(t) { let e = tt(t); if (!gt(e.shape, this.weights.shape)) throw "Weights shapes don't match"; this.weights = e } getWeights() { return this.weights.copy() } setBias(t) { let e = tt(t); if (!gt(e.shape, this.bias.shape)) throw "Bias shapes don't match"; this.bias = e } getBias() { return this.bias.copy() } mutate(t = .1, e) { this.weights.map(i => Math.random() < t ? H(e) : i), this.bias.map(i => Math.random() < t ? H(e) : i) } mutateWeights(t, e) { this.weights.map(i => Math.random() < t ? H(e) : i) } mutateBias(t, e) { this.bias.map(i => Math.random() < t ? H(e) : i) } } class lt extends vt { constructor(t) { super(); u(this, "units"); u(this, "outputShape"); u(this, "inputShape"); u(this, "biasInitializer"); u(this, "kernelInitializer"); this.type = "dense", typeof t.activation == "string" && (this.activation = t.activation, this.activationFunction = Mt(this.activation)), this.isTrainable = !0, this.units = Math.floor(t.units), this.outputShape = this.units, this.kernelInitializer = ht(), t.kernelInitializer instanceof T ? this.kernelInitializer = t.kernelInitializer : typeof t.kernelInitializer == "string" && (this.kernelInitializer = J(t.kernelInitializer)()), this.biasInitializer = x(), t.biasInitializer instanceof T ? this.biasInitializer = t.biasInitializer : typeof t.biasInitializer == "string" && (this.biasInitializer = J(t.biasInitializer)()), this.inputShape = t.inputShape ? Math.floor(t.inputShape) : 1, this.weights = this.kernelInitializer.apply([this.units, this.inputShape]), this.bias = this.biasInitializer.apply([this.units]), this.weightsConstrain = t.weightsConstrain || [-1e7, 1e7], this.biasConstrain = t.biasConstrain || [-1e7, 1e7], this.weightsGradient = y(this.weights.shape), this.biasGradient = y(this.bias.shape), this.optimizerWeights = [this.weightsGradient, y(this.weights.shape), y(this.weights.shape)], this.optimizerBias = [this.biasGradient, y(this.bias.shape), y(this.bias.shape)], this.parameters = this.units * this.inputShape + this.outputShape, t.weights !== void 0 && this.setParameters(t) } resize(t) { this.inputShape = t instanceof Array ? t[0] : t, this.weights = this.kernelInitializer.apply([this.units, this.inputShape]), this.bias = this.biasInitializer.apply([this.units]), this.reshapeOptimizerParameters(), this.parameters = this.units * this.inputShape + this.outputShape } forward(t) { if (this.inputBatch = t, this.activation !== void 0) { for (let e = 0; e < this.inputBatch.length; e++)this.output[e] = this.activationFunction.fn(X(this.weights, this.inputBatch[e]).add(this.bias)); return this.output } for (let e = 0; e < this.inputBatch.length; e++)this.output[e] = X(this.weights, this.inputBatch[e]).add(this.bias); return this.output } backward(t) { let e = t, i = Ft(this.weights), a = []; for (let r = 0; r < t.length; r++) { this.activation !== void 0 && (e[r] = this.activationFunction.updateError(t[r], this.activationFunction.fnPrime(this.output[r]))); let n = Ft(this.inputBatch[r]), l = X(e[r], n); this.weightsGradient.add(l), this.biasGradient.add(e[r]), a[r] = X(i, e[r]) } return a } } class yt extends vt { constructor(t) { super(); u(this, "filters"); u(this, "padding"); u(this, "kernelSize"); u(this, "inputShape"); u(this, "stride"); u(this, "dilation"); u(this, "kernelShape"); u(this, "padAmt"); u(this, "kernelGradientPad"); u(this, "inputGradientPad"); u(this, "outputShape"); u(this, "kernelInitializer"); u(this, "biasInitializer"); typeof t.activation == "string" && (this.activation = t.activation, this.activationFunction = Mt(this.activation)), this.type = "conv", this.name = this.type, this.isTrainable = !0, this.filters = Math.floor(t.filters), this.padding = t.padding || "valid", t.weightsConstrain && (this.weightsConstrain = t.weightsConstrain), t.biasConstrain && (this.biasConstrain = t.biasConstrain), this.kernelInitializer = ht(), t.kernelInitializer instanceof T ? this.kernelInitializer = t.kernelInitializer : typeof t.kernelInitializer == "string" && (this.kernelInitializer = J(t.kernelInitializer)()), this.biasInitializer = x(), t.biasInitializer instanceof T ? this.biasInitializer = t.biasInitializer : typeof t.biasInitializer == "string" && (this.biasInitializer = J(t.biasInitializer)()), this.kernelSize = typeof t.kernelSize == "number" ? this.kernelSize = [t.kernelSize, t.kernelSize] : [t.kernelSize[0], t.kernelSize[1]], this.kernelSize.map(e => Math.floor(e)), this.stride = [1, 1], t.stride && (this.stride = t.stride instanceof Array ? t.stride : [t.stride, t.stride], this.stride.map(e => Math.floor(e))), this.dilation = [1, 1], t.dilation && (this.dilation = t.dilation instanceof Array ? t.dilation : [t.dilation, t.dilation], this.dilation.map(e => Math.floor(e))), this.kernelGradientPad = "valid", this.inputGradientPad = "full", this.padding == "same" && (this.kernelGradientPad = [this.kernelSize[0] - 1, this.kernelSize[1] - 1], this.inputGradientPad = "same"), this.inputShape = t.inputShape ? t.inputShape.slice() : [1, 1, 1], this.inputShape.map(e => Math.floor(e)), this.kernelShape = [this.filters, this.inputShape[0], this.kernelSize[0], this.kernelSize[1]], this.padAmt = q(this.inputShape, this.kernelShape, this.padding, this.stride, this.dilation), this.outputShape = Z(this.inputShape, this.kernelShape, this.padAmt, this.stride, this.dilation), this.weights = this.kernelInitializer.apply(this.kernelShape), this.bias = this.biasInitializer.apply(this.outputShape), this.weightsGradient = y(this.weights.shape), this.biasGradient = y(this.bias.shape), this.optimizerWeights = [this.weightsGradient, y(this.weights.shape), y(this.weights.shape)], this.optimizerBias = [this.biasGradient, y(this.bias.shape), y(this.bias.shape)], this.parameters = this.weights.size() + this.bias.size(), t.weights !== void 0 && this.setParameters(t) } resize(t) { this.inputShape = t instanceof Array ? t : [1, 1, 1], this.inputShape.map(e => Math.floor(e)), this.kernelShape = [this.filters, this.inputShape[0], this.kernelSize[0], this.kernelSize[1]], this.padAmt = q(this.inputShape, this.kernelShape, this.padding, this.stride, this.dilation), this.outputShape = Z(this.inputShape, this.kernelShape, this.padAmt, this.stride, this.dilation), this.weights = this.kernelInitializer.apply(this.kernelShape), this.bias = this.biasInitializer.apply(this.outputShape), this.weightsGradient = y(this.weights.shape), this.biasGradient = y(this.bias.shape), this.optimizerWeights = [this.weightsGradient, y(this.weights.shape), y(this.weights.shape)], this.optimizerBias = [this.biasGradient, y(this.bias.shape), y(this.bias.shape)], this.parameters = this.weights.size() + this.bias.size() } forward(t) { if (this.input = t, this.activation !== void 0) { for (let e = 0; e < this.input.length; e++)this.output[e] = this.activationFunction.fn(Bt(this.input[e], this.weights, this.bias, this.padding, this.stride, this.dilation)); return this.output } for (let e = 0; e < this.input.length; e++)this.output[e] = Bt(this.input[e], this.weights, this.bias, this.padding, this.stride, this.dilation); return this.output } backward(t) { let e = t, i = []; for (let a = 0; a < t.length; a++) { i[a] = y(this.inputShape), this.activation !== void 0 && (e[a] = this.activationFunction.fnPrime(this.output[a])); let r = []; for (let n = 0; n < this.kernelShape[0]; n++) { r[n] = []; for (let l = 0; l < this.kernelShape[1]; l++) { r[n][l] = pe(this.input[a].data[l], e[a].data[n], this.kernelGradientPad).data; let o = ce(e[a].data[n], this.weights.data[n][l], this.inputGradientPad); i[a].data[l] = G(i[a].data[l], o).data } } r = new p(r, this.kernelShape), this.weightsGradient.add(r), this.biasGradient.add(e[a]) } return i } } class Xt extends Q { constructor(t = {}) { super(); u(this, "poolSize"); u(this, "stride"); u(this, "padding"); u(this, "padAmt"); u(this, "inputShape"); u(this, "coords"); u(this, "outputShape"); this.type = "maxpooling", this.poolSize = [2, 2], t.poolSize && (this.poolSize = t.poolSize instanceof Array ? t.poolSize : [t.poolSize, t.poolSize], this.poolSize.map(e => Math.floor(e))), this.stride = this.poolSize, t.stride && (this.stride = t.stride instanceof Array ? t.stride : [t.stride, t.stride], this.stride.map(e => Math.floor(e))), this.padding = t.padding || !1, this.inputShape = t.inputShape ? t.inputShape.slice() : [1, 1, 1], this.inputShape.map(e => Math.floor(e)), this.padAmt = rt(this.inputShape, this.padding, this.poolSize, this.stride), this.outputShape = zt(this.inputShape, this.padAmt, this.poolSize, this.stride), this.coords = t.coords ? t.coords.slice() : [] } resize(t) { this.inputShape = t instanceof Array ? t.slice() : [1, 1, 1], this.inputShape.map(e => Math.floor(e)), this.padAmt = rt(this.inputShape, this.padding, this.poolSize, this.stride), this.outputShape = zt(this.inputShape, this.padAmt, this.poolSize, this.stride) } forward(t) { this.input = t; let e = []; for (let i = 0; i < t.length; i++)this.coords[i] = [], e[i] = de(this.input[i], this.padding, this.poolSize, this.stride, this.coords[i]); return e } backward(t) { let e = []; for (let i = 0; i < this.input.length; i++) { e[i] = y(this.inputShape); for (let a = 0; a < this.coords[i].length; a++)e[i].data[this.coords[i][a][0]][this.coords[i][a][1]][this.coords[i][a][2]] = t[i].data[this.coords[i][a][0]][this.coords[i][a][3]][this.coords[i][a][4]] } return e } } class Zt extends Q { constructor(t = {}) { super(); u(this, "inputShape"); u(this, "outputShape"); this.type = "flatten", this.inputShape = t.inputShape instanceof Array ? t.inputShape.slice() : [1, 1, 1], this.inputShape.map(e => Math.floor(e)), this.outputShape = 1; for (let e = 0; e < this.inputShape.length; e++)this.outputShape *= this.inputShape[e] } resize(t) { this.inputShape = t instanceof Array ? t.slice() : [1, 1, 1], this.inputShape.map(e => Math.floor(e)), this.outputShape = 1; for (let e = 0; e < this.inputShape.length; e++)this.outputShape *= this.inputShape[e] } forward(t) { this.input = t; let e = []; for (let i = 0; i < t.length; i++) { let a = []; this.input[i].forEach(r => (a.push(r), r)), e[i] = new p(a, [this.outputShape]) } return e } backward(t) { let e = []; for (let i = 0; i < t.length; i++) { let a = [], r = 0; for (let n = 0; n < this.inputShape[0]; n++) { a[n] = []; for (let l = 0; l < this.inputShape[1]; l++) { a[n][l] = []; for (let o = 0; o < this.inputShape[2]; o++)a[n][l][o] = t[i].data[r], r++ } } e[i] = new p(a, this.inputShape) } return e } serialize() { return JSON.stringify(this) } } class Kt extends Q { constructor(t = {}) { super(); u(this, "rate"); u(this, "inputShape"); u(this, "outputShape"); this.type = "dropout", this.rate = t.rate || .1, this.inputShape = t.inputShape ? t.inputShape : 1, this.outputShape = this.inputShape } resize(t) { this.inputShape = t, this.outputShape = this.inputShape } forward(t) { this.input = t; let e = []; for (let i = 0; i < t.length; i++)e[i] = new p(C(this.input[i].data, a => Math.random() < this.rate ? 0 : a), this.input[i].shape); return e } backward(t) { return t } serialize() { return JSON.stringify(this) } } class bt extends vt { constructor(t = {}) { super(); u(this, "inputShape"); u(this, "internInputShape"); u(this, "norm"); u(this, "xmu"); u(this, "variance"); u(this, "outputShape"); u(this, "kernelInitializer"); u(this, "biasInitializer"); this.type = "norm", this.isTrainable = !0, this.inputShape = 1, t.inputShape instanceof Array && (this.inputShape = t.inputShape.slice().map(e => Math.floor(e))), typeof t.inputShape == "number" && (this.inputShape = Math.floor(t.inputShape)), this.outputShape = this.inputShape, this.internInputShape = this.inputShape instanceof Array ? this.inputShape.slice().map(e => Math.floor(e)) : [Math.floor(this.inputShape)], this.kernelInitializer = kt(), t.kernelInitializer instanceof T ? this.kernelInitializer = t.kernelInitializer : typeof t.kernelInitializer == "string" && (this.kernelInitializer = J(t.kernelInitializer)()), this.biasInitializer = x(), t.biasInitializer instanceof T ? this.biasInitializer = t.biasInitializer : typeof t.biasInitializer == "string" && (this.biasInitializer = J(t.biasInitializer)()), this.weights = this.kernelInitializer.apply(this.internInputShape), this.bias = this.biasInitializer.apply(this.internInputShape), this.reshapeOptimizerParameters(), this.norm = new p([]), this.xmu = new p([]), this.variance = 0, this.activation = "linear", typeof t.activation == "string" && (this.activation = t.activation, this.activationFunction = Mt(this.activation)), t.weights !== void 0 && this.setParameters(t) } resize(t) { this.inputShape = t instanceof Array ? t.slice().map(e => Math.floor(e)) : Math.floor(t), this.outputShape = this.inputShape, this.internInputShape = t instanceof Array ? t.slice().map(e => Math.floor(e)) : [Math.floor(t)], this.weights = this.kernelInitializer.apply(this.internInputShape), this.bias = this.biasInitializer.apply(this.internInputShape), this.reshapeOptimizerParameters(), this.parameters = this.weights.size() + this.bias.size() } forward(t) { this.input = t; for (let e = 0; e < t.length; e++) { this.xmu = F(this.input[e], this.input[e].mean()), this.variance = ne(this.input[e]) + 1e-7, this.norm = E(this.xmu, this.variance ** .5); let i = k(this.weights, this.norm).add(this.bias); this.output[e] = this.activationFunction.fn(i) } return this.output } backward(t) { let e = []; for (let i = 0; i < t.length; i++) { let a = this.activationFunction.updateError(t[i], this.activationFunction.fnPrime(this.output[i])), r = k(a, this.norm); this.weightsGradient.add(r), this.biasGradient.add(a); let n = 1 / this.variance ** .5; e[i] = k(a, this.weights); let l = k(e[i], this.xmu).mult(-.5).mult(this.variance ** (-3 / 2)), o = k(e[i], -n).add(k(l, E(1 / t.length, k(this.xmu, -2)))); e[i] = k(e[i], n).add(G(E(o, t.length), E(k(l, 2 / t.length), this.xmu))) } return e } } class P extends Q { constructor(t) { super(); u(this, "fn"); u(this, "fnPrime"); u(this, "updateError"); u(this, "forwardedInput"); u(this, "inputShape"); u(this, "outputShape"); this.isTrainable = !1, this.type = "activation", this.name = t.name, this.fn = t.fn, this.fnPrime = t.fnPrime, this.updateError = t.updateError, this.inputShape = 0, this.outputShape = this.inputShape, this.forwardedInput = [new p([])] } resize(t) { this.inputShape = t, this.outputShape = this.inputShape } forward(t) { this.input = t; for (let e = 0; e < t.length; e++)this.forwardedInput[e] = this.fn(t[e]); return this.forwardedInput } backward(t) { let e = []; for (let i = 0; i < t.length; i++)e[i] = this.updateError(t[i], this.fnPrime(this.forwardedInput[i])); return e } serialize() { return JSON.stringify(this) } } const Te = s => { switch (s) { case "dense": return lt; case "conv": return yt; case "maxpooling": return Xt; case "flatten": return Zt; case "dropout": return Kt; case "norm": return bt; case "activation": return P; default: return lt } }, Ce = s => { let t = Te(s.type); return new t(s) }, us = s => new lt(s), fs = s => new yt(s), ps = s => new Xt(s), cs = s => new bt(s), ds = s => new Zt(s), ms = s => new Kt(s), Fe = s => { switch (s) { case "sigmoid": return new P(nt); case "relu": return new P(Dt); case "binaryStep": return new P(Lt); case "tanh": return new P(qt); case "softmax": return new P(Gt); default: return new P(nt) } }; var gs = Object.freeze({ __proto__: null, [Symbol.toStringTag]: "Module", Layer: Q, TrainableLayer: vt, handler: Te, fromObject: Ce, dense: us, conv: fs, maxPooling: ps, norm: cs, flatten: ds, dropout: ms, activation: Fe, ActivationClass: P, DenseClass: lt, ConvClass: yt, MaxPoolingClass: Xt, FlattenCLass: Zt, DropoutClass: Kt, NormClass: bt }); class ot { constructor(t) { u(this, "fn"); u(this, "fnPrime"); u(this, "type"); u(this, "name"); this.fn = t.fn, this.fnPrime = t.fnPrime, this.type = "loss", this.name = t.name } serialize() { return JSON.stringify(this) } } const It = new ot({ fn: (s, t) => re(t, s).mean(), fnPrime: (s, t) => F(s, t).mult(2).div(Tt(s)), name: "mse" }), Ne = new ot({ fn: (s, t) => -k(t, st(s)).sum(), fnPrime: (s, t) => k(t, E(-1, s)), name: "crossEntropy" }), Oe = new ot({ fn: (s, t) => { let e = F(s, St(s)), i = wt(it(e), et(e)); return -k(t, st(i)).sum() }, fnPrime: (s, t) => { let e = F(s, St(s)), i = E(it(e), et(e)); return F(i, t) }, name: "softmaxCrossEntropy" }), _e = new ot({ fn: (s, t) => { let e = k(t, st(s)), i = F(1, t), a = st(F(1, s)); return -G(e, k(i, a)).mean() }, fnPrime: (s, t) => { let e = E(F(1, t), F(1, s)), i = E(t, s), a = F(e, i); return E(a, Tt(a)) }, name: "binaryCrossEntropy" }), ut = s => { switch (s) { case "mse": return It; case "crossEntropy": return Ne; case "softmaxCrossEntropy": return Oe; case "binaryCrossEntropy": return _e; default: return It } }; var ws = Object.freeze({ __proto__: null, [Symbol.toStringTag]: "Module", Loss: ot, meanSquaredError: It, crossEntropy: Ne, softmaxCrossEntropy: Oe, binaryCrossEntropy: _e, handler: ut }); class ft { constructor() { u(this, "args"); u(this, "name"); this.args = [], this.name = "" } apply(t, e, i = 0) { t.sub(k(e[0], i)) } } class Be extends ft { constructor(t) { super(); this.name = "sgd", this.args = t } apply(t, e) { t.sub(k(e[0], this.args[0])) } } const pt = (s = .1) => new Be([s]); class Re extends ft { constructor(t) { super(); this.name = "momentum", this.args = t } apply(t, e) { e[1] == null && t.sub(k(k(e[0], 1 - this.args[1]), this.args[0])), e[1] = k(e[1], this.args[1]).add(k(e[0], 1 - this.args[1])), t.sub(k(e[1], this.args[0])) } } const De = (s = .1, t = .9) => new Re([s, t]); class Le extends ft { constructor(t) { super(); this.name = "rmsprop", this.args = t } apply(t, e) { if (e[1] == null) { let i = k(U(e[0]), 1 - this.args[1]); t.sub(k(E(e[0], G(i, this.args[2]).sqrt()), this.args[0])) } else e[1] = k(e[1], this.args[1]).add(k(U(e[0]), 1 - this.args[1])), t.sub(k(E(e[0], G(e[1], this.args[2]).sqrt()), this.args[0])) } } const qe = (s = .01, t = .9, e = 1e-7) => new Le([s, t, e]); class Ge extends ft { constructor(t) { super(); this.name = "adam", this.args = t } apply(t, e, i = 0) { if (e[1] == null) { let a = k(e[0], 1 - this.args[1]), r = k(U(e[0]), 1 - this.args[2]), n = E(a, 1 - this.args[1]), l = E(r, 1 - this.args[2]); t.sub(k(E(n, G(l, this.args[3]).sqrt()), this.args[0])) } else { e[1] = k(e[1], this.args[1]).add(k(e[0], 1 - this.args[1])), e[2] = k(e[2], this.args[2]).add(k(U(e[0]), 1 - this.args[2])); let a = E(e[1], 1 - this.args[1] ** i), r = E(e[2], 1 - this.args[2] ** i); t.sub(k(E(a, G(r, this.args[3]).sqrt()), this.args[0])) } } } const Pe = (s = .1, t = .9, e = .999, i = 1e-7) => new Ge([s, t, e, i]), Ve = s => { switch (s.name) { case "sgd": return pt(s.args); case "momentum": return De(s.args); case "rmsprop": return qe(s.args); case "adam": return Pe(s.args); default: return pt() } }; var Ss = Object.freeze({ __proto__: null, [Symbol.toStringTag]: "Module", Optimizer: ft, Sgd: Be, sgd: pt, Momentum: Re, momentum: De, Rmsprop: Le, rmsprop: qe, Adam: Ge, adam: Pe, fromObject: Ve }); class ct { constructor() { u(this, "layers"); u(this, "numLayers"); u(this, "trainableLayers"); u(this, "error"); u(this, "loss"); u(this, "lossFunction"); u(this, "optimizer"); u(this, "parameters"); u(this, "batch"); u(this, "batchSize"); this.batch = 0, this.parameters = 0, this.layers = [], this.numLayers = 0, this.loss = "mse", this.lossFunction = ut(this.loss), this.trainableLayers = [], this.error = 1, this.optimizer = pt(.1), this.batchSize = 0 } setLossFunction(t) { this.loss = t, this.lossFunction = ut(this.loss) } compile(t) { this.optimizer = t.optimizer || pt(.1), typeof t.loss == "string" ? (this.loss = t.loss, this.lossFunction = ut(this.loss)) : (this.lossFunction = t.loss || It, this.loss = this.lossFunction.name) } add(t, e = !1) { if (this.numLayers > 0 && e == !1) { let i = this.layers[this.numLayers - 1].outputShape; t.resize(i) } (t instanceof lt || t instanceof yt || t instanceof bt) && (this.trainableLayers.push(t), this.parameters += t.parameters), this.layers.push(t), this.numLayers++ } predict(t) { let e = !1, i; t instanceof p ? (e = !0, i = [t]) : i = t; for (let a = 0; a < this.numLayers; a++)i = this.layers[a].forward(i); return e ? i[0] : i } train(t, e, i = { epochs: 1, batchSize: 1, shuffle: !1 }) { let a = i.shuffle || !1, r = i.epochs || 1; this.batchSize = i.batchSize || t.length; for (let n = 0; n < r; n++)for (let l = 0; l < t.length / this.batchSize; l++) { let o = t.slice(l, l + this.batchSize), f = e.slice(l, l + this.batchSize); this.trainOnBatch(o, f, a) } this.batch > t.length / this.batchSize && (this.batch = 0) } trainOnBatch(t, e, i = !1) { this.batchSize == 0 && (this.batchSize = t.length), i && $t(t, e), this.error = 0; let a = this.predict(t), r = []; for (let n = 0; n < this.batchSize; n++)this.error += this.lossFunction.fn(a[n], e[n]), r[n] = this.lossFunction.fnPrime(a[n], e[n]); for (let n = this.numLayers - 1; n >= 0; n--)r = this.layers[n].backward(r); this.batch++, this.error /= this.batchSize, this.update(this.batch) } update(t) { for (let e = 0; e < this.trainableLayers.length; e++)this.trainableLayers[e].update(this.optimizer, this.batchSize, t) } static fromObject(t) { let e = new ct; for (let i = 0; i < t.layers.length; i++) { let a; t.layers[i].type == "activation" ? (a = Fe(t.layers[i].name), e.add(a)) : (a = Ce(t.layers[i]), e.add(a, !0)) } return e.batch = e.batch, e.loss = t.loss, e.lossFunction = ut(e.loss), e.error = t.error, e.optimizer = Ve(t.optimizer), e } copy() { return ct.fromObject(JSON.parse(JSON.stringify(this))) } static copy(t) { return ct.fromObject(JSON.parse(JSON.stringify(t))) } mutateRandomLayer(t = !1, e = .1, i = .1) { let a = Math.floor(Math.random() * this.trainableLayers.length); this.trainableLayers[a].weights.forEach(r => Math.random() < e ? r + (2 * Math.random() * i - i) : r), t != !1 && this.trainableLayers[a].bias.forEach(r => Math.random() < e ? r + (2 * Math.random() * i - i) : r) } mutate(t = !1, e = .1, i = .5) { for (let a = 0; a < this.trainableLayers.length; a++)this.trainableLayers[a].weights.forEach(r => Math.random() < e ? r + (2 * Math.random() * i - i) : r), t != !1 && this.trainableLayers[a].bias.forEach(r => Math.random() < e ? r + (2 * Math.random() * i - i) : r) } serialize() { return JSON.stringify(this) } } h.NeuralNet = ct, h.Tensor = p, h.abs = Si, h.accesLastArray = hi, h.accesLastArrayReturn = li, h.accesLastArrays = oi, h.accesLastArraysReturn = ui, h.acos = zi, h.acosh = Mi, h.activations = ls, h.add = G, h.arithOp = L, h.arraysEqual = ti, h.asin = ki, h.asinh = vi, h.atan = yi, h.atan2 = di, h.broadcastArgs = ie, h.broadcastTo = B, h.c_c_outputShape = Nt, h.c_c_paddAmount = q, h.cbrt = bi, h.cc_manyFilters_outputShape = Z, h.cc_reuseFilter_outputShape = _t, h.ccv_outputShape = Ot, h.ceil = Ii, h.changeRange = Zi, h.constrain = Ki, h.conv_manyFilters = ns, h.conv_reuseFilter = rs, h.convolution = ce, h.copy = tt, h.corr_manyFilters = as, h.corr_manyFilters_addB = Bt, h.corr_reuseFilter = ss, h.correlate = pe, h.cos = Ai, h.cosh = Ei, h.create = He, h.div = wt, h.divNoNan = E, h.dot = X, h.dotMxM = he, h.dotMxV = le, h.dotVxM = oe, h.dotVxV = ue, h.elu = Wi, h.ensureTensor = w, h.exp = it, h.expNoInfinity = Yi, h.expm1 = Ti, h.fill = mt, h.flatten = jt, h.floor = Ci, h.floorDiv = fi, h.floorDivNoNan = pi, h.forEach = se, h.forEachOfBoth = ni, h.forEachOfBothReturn = ae, h.forEachReturn = C, h.fromArray = At, h.fromObject = Y, h.fromVector = D, h.identity = Xe, h.inferRank = $e, h.inferShape = _, h.initializers = os, h.layer = gs, h.leakyRelu = Ui, h.log = st, h.log10 = Fi, h.log2 = Ni, h.logNoNan = $i, h.losses = ws, h.map = N, h.mathOP = b, h.max = St, h.maxPooling = hs, h.maxPoolingVolume = de, h.mean = mi, h.min = Ct, h.mirrorHorizontally = ji, h.mirrorVertically = ts, h.mp_outputShape = fe, h.mp_paddAmount = rt, h.mp_v_outputShape = zt, h.mult = k, h.neg = wi, h.oneHot = Qe, h.ones = Yt, h.onesLike = Ke, h.optimizers = Ss, h.padding = R, h.pow = ci, h.random = ii, h.randomNormal = j, h.randomUniform = $, h.range = Ye, h.rangeOfValues = ei, h.relu = Vi, h.remap = Xi, h.reshape = te, h.rotate180 = at, h.rotate270 = is, h.rotate90 = es, h.round = Oi, h.scalar = Je, h.shapesEqual = gt, h.shuffle = je, h.shuffleMatch = $t, h.sigmoid = Pi, h.sign = _i, h.sin = Bi, h.sinh = Ri, h.size = Tt, h.softmax = Hi, h.softplus = xi, h.sqd = re, h.sqrt = Di, h.square = U, h.stack = ai, h.step = Ji, h.sub = F, h.sum = gi, h.sumExp = et, h.tan = Li, h.tanh = qi, h.tensor = Et, h.tile = ee, h.transpose = Ft, h.trunc = Gi, h.unstack = ri, h.util = xe, h.variance = Qi, h.varianceSquared = ne, h.vectorToTensor = si, h.zeros = y, h.zerosLike = Ze, Object.defineProperty(h, "__esModule", { value: !0 }), h[Symbol.toStringTag] = "Module" });
